---
title: 'TCGA - outlier functions'
output: html_document
editor_options: 
  chunk_output_type: console
---

## Make Outlier.function
```{r}

### Outlier.function.Rmd #######################################################
################################################################################
### 1. Function for making z-score matrix using each method (8 methods)
# - Generate function for calculating z-score and Kmean cluster using each method
#   1. Use mean and SD
#   2. Use mean and SD excluding zero values
#   3. Use trimmed mean and trimmed SD
#   4. Use trimmed mean and trimmed SD excluding zero values
#   5. Use median and MAD
#   6. Use median and MAD excluding zero values
#   7. Use K mean cluster
#   8. Use K mean cluster excluding zero values

### 2. Function for outlier detection (calculating z-score range and kmean fraction)
# - Generate function for calculating z-score range and kmean fraction
#   1. Calculate a range of z-score
#   2. Calculate a fraction of Kmean with smaller fraction
# - Generate gene-wise matrix

### 3. Function for checking whether the outliers are highly abundant or lowly abundant
# - Generate the direction matrix

### 4. Function for making patient-wise outlier matrix
# 1. P-value < 0.05
# 2. Bonferroni  correction < 0.05
# 3. Adjusted p-value < 0.05
# - Generate function for marking the patients over/under threshold
# - Generate function for calculating the number of outliers per patient

### 5. File check - match the name of patients
# - Match the name of patients between FPKM file and z-score file

### 6. Function for making heatmap of z-score and FPKM
# - Generate function for making heatmap in z-score and fpkm space

### 7. Function for making Waterfall plot
# - Generate function for making waterfall plot with z-score and FPKM with showing the fraction of patients

### 8. Function for checking out the technical problem
# - Generate heatmap for the fraction of genes enriched on each chromosome
# - Check if there is any chromosome of which genes are enriched less than 20%

### 9. Function for making heatmap of each chromosome position
# - Generate function for making heatmap for each chromosomal position

### 10. Function for ranking outliers
# - Generate the ranking of outliers using rank product method
# - Generate heatmap for top 1000 ranked outliers in FPKM space
# - Generate heatmap for top 1000 ranked outliers in z-score
# - Count the number of outliers per patient
# - Generate heatmap for top 1000 ranked outliers ordered by the number of outliers per patient

### 11. Function for making multi-waterfall plot with clinical data
# 1. ISUP
# 2. PSA
# 3. Age
# 4. Tumor grade
# - Merge clinical data in waterfall plot

### 12. Function for making bar plot of gene rank on each chromosome position
# - Generate bar plot for each chromosome with rank of genes

### 13. File check - Check the correlation between FPKM and z-score
# - Generate an error if the correlation is low

### 14. Save session 

################################################################################



### Input Variable #############################################################
#TCGA prostate cancer RNA-seq data - 2018-05-31_rnaseq_rsem_gene_FPKM.txt
#                                    2018-07-23_rnaseq_rsem_gene_FPKM.txt
setwd('~/Documents/1.Project/1.CPCGENE_RNA-seq/Rawdata/TCGA_PC');
fpkm.data <- read.delim(
    file = '2018_rnaseq_rsem_gene_FPKM.txt',
    row.names = 1
    );

#Give variable
# input file : FPKM normalized RNA-seq data
# input variable : fpkm.data - raw FPKM data
#                  patient.part - exclude Symbol column for downstream analysis
#                  molecular.data - data without Symbol column. Only have FPKM data
patient.part <- 1:(ncol(fpkm.data)-1);
molecular.data <- fpkm.data[, patient.part];



### Load session #####
# setwd('~/Documents/1.Project/1.CPCGENE_RNA-seq/Rawdata/TCGA_PC');
# load(file = '2020-12-15_TCGA_gene-wise_Outlier.rda');
# load(file = '2020-12-15_TCGA_patient-wise_Outlier.rda');
# Clinical data
setwd('~/Documents/1.Project/1.CPCGENE_RNA-seq/Rawdata/Clinical_data/');
clinical.data <- read.delim(
    file = 'prad_tcga_clinical_data.tsv'
    );

```


## 1. Function for making z-score matrix using each method (8 methods)#####
```{r}

### Outlier.Function ###########################################################
### MEAN and SD #####
# Function parameter
# Default : methods = 'mean', trim = 0, exclude.zero = FALSE
# 1. MEAN and SD : methods = 'mean', trim = 0, exclude.zero = FALSE
# 2. MEAN and SD excluding zero : methods = 'mean', trim = 0, exclude.zero = TRUE
# 3. TRIMMED MEAN and TRIMMED SD : methods = 'mean', trim = 5, exclude.zero = FALSE
# 4. TRIMMED MEAN and TRIMMED SD excluding zero : methods = 'mean', trim = 5, exclude.zero = TRUE
# 5. MEDIAN and MAD : methods = 'median', exclude.zero = FALSE
# 6. MEDIAN and MAD excluding zero : methods = 'median', exclude.zero = TRUE
# 7. KMEAN : methods = 'kmean', exclude.zero = FALSE
# 8. KMEAN excluding zero : methods = 'kmean', exclude.zero = TRUE

# Function - outlier.mean()
quantify.outliers <- function(x, method = 'mean', trim = 0, exclude.zero = FALSE) {
    x.num <- as.numeric(x); #names(x) will need for final output
    if (any(is.na(x.num))) {
        x <- 0;
        }
    else {
        if ('median' == method) {
            if (exclude.zero) { 
                x.nonzero <- x.num[0 != x.num]; 
                x.median <- median(x.nonzero);
                x.mad <- mad(x.nonzero);
                } 
            else {
                x.median <- median(x.num);
                x.mad <- mad(x.num);
                }
            (x - x.median) / x.mad;
            }
        else if ('kmean' == method) {
            if (exclude.zero) {
                if (1 == length(unique(as.numeric(x.num))) ) {
                    kmean.matrix <- rep(NA, length(x.num));
                    names(kmean.matrix) <- names(x);
                    } 
                else {
                    x.order <- sort(x.num, decreasing = TRUE);
                    non.zero <- x.order[x.order > 0];
                    if (length(unique(as.numeric(non.zero))) <= 2) {
                        na.matrix <- rep(NA, length(non.zero));
                        cluster.zero <- c(na.matrix, rep(0, length(x.num[x.num == 0])));
                        kmean.matrix <- cluster.zero[match(x.num, x.order)];
                        names(kmean.matrix) <- names(x);  
                        } 
                    else {
                        kmean <- kmeans(non.zero, 2, nstart = 1000);
                        cluster <- kmean$cluster;
                        cluster.zero <- c(cluster, rep(0, length(x.num[x.num == 0])));
                        kmean.matrix <- cluster.zero[match(x.num, x.order)];
                        names(kmean.matrix) <- names(x);   
                        }
                    }
                } 
            
            else {
                if (1 == length(unique(x.num))) {
                    kmean.matrix <- rep(NA, length(x.num));
                    names(kmean.matrix) <- names(x);  
                    } 
                else {
                    kmean <- kmeans(x.num, 2, nstart = 1000);
                    cluster <- kmean$cluster;
                    kmean.matrix <- cluster;
                    names(kmean.matrix) <- names(x);  
                    }
                }
            kmean.matrix;
            }
        else {
            gene.order <- x.num[order(x.num, decreasing = TRUE)];
            if (exclude.zero) { 
                gene.order.nonzero <- gene.order[0 != gene.order]; 
                top.patient <- round(length(gene.order.nonzero) * (trim / 100), digit = 0);
                low.patient <- round(length(gene.order.nonzero) * (1 - (trim / 100)), digit = 0);
                x.mean <- mean(gene.order.nonzero, trim = (trim / 100));
                x.sd <- sd(gene.order.nonzero[(top.patient+1):(low.patient)]);
                } 
            else {
                top.patient <- round(length(x.num) * (trim / 100), digit = 0);
                low.patient <- round(length(x.num) * (1 - (trim / 100)), digit = 0);
                x.mean <- mean(gene.order, trim = (trim / 100));
                x.sd <- sd(gene.order[(top.patient+1):(low.patient)]);
                }
            (x - x.mean) / x.sd;
            }
        }
    }


# 1. MEAN and SD : method = 'mean', trim = 0, exclude.zero = FALSE
molecular.mean <- apply(molecular.data, 1, quantify.outliers);
molecular.mean.t <- t(molecular.mean);
molecular.mean.t <- data.frame(molecular.mean.t);

# 2. MEAN and SD excluding zero : method = 'mean', trim = 0, exclude.zero = TRUE
molecular.mean.nonzero <- apply(molecular.data, 1, quantify.outliers, exclude.zero = TRUE);
molecular.mean.nonzero.t <- t(molecular.mean.nonzero);
molecular.mean.nonzero.t <- data.frame(molecular.mean.nonzero.t);

# 3. TRIMMED MEAN and TRIMMED SD : method = 'mean', trim = 5, exclude.zero = FALSE
molecular.trimmean <- apply(molecular.data, 1, quantify.outliers, trim = 5);
molecular.trimmean.t <- t(molecular.trimmean);
molecular.trimmean.t <- data.frame(molecular.trimmean.t);

# 4. TRIMMED MEAN and TRIMMED SD excluding zero : method = 'mean', trim = 5, exclude.zero = TRUE
molecular.trimmean.nonzero <- apply(molecular.data, 1, quantify.outliers, trim = 5, exclude.zero = TRUE);
molecular.trimmean.nonzero.t <- t(molecular.trimmean.nonzero);
molecular.trimmean.nonzero.t <- data.frame(molecular.trimmean.nonzero.t);

# 5. MEDIAN and MAD : method = 'median', exclude.zero = FALSE
molecular.median <- apply(molecular.data, 1, quantify.outliers, method = 'median');
molecular.median.t <- t(molecular.median);
molecular.median.t <- data.frame(molecular.median.t);

# 6. MEDIAN and MAD excluding zero : method = 'median', exclude.zero = TRUE
molecular.median.nonzero <- apply(molecular.data, 1, quantify.outliers, method = 'median', exclude.zero = TRUE);
molecular.median.nonzero.t <- t(molecular.median.nonzero);
molecular.median.nonzero.t <- data.frame(molecular.median.nonzero.t);

# 7. KMEAN : method = 'kmean', exclude.zero = FALSE
molecular.kmean <- apply(molecular.data, 1, quantify.outliers, method = 'kmean');
molecular.kmean.t <- t(molecular.kmean);
molecular.kmean.t <- data.frame(molecular.kmean.t);

# 8. KMEAN excluding zero : method = 'kmean', exclude.zero = TRUE
molecular.kmean.nonzero <- apply(molecular.data, 1, quantify.outliers, method = 'kmean', exclude.zero = TRUE);
molecular.kmean.nonzero.t <- t(molecular.kmean.nonzero);
molecular.kmean.nonzero.t <- data.frame(molecular.kmean.nonzero.t);


```



## 2. Function for outlier detection (calculating z-score range and kmean fraction) 
```{r}
### Calculate the range of z-score #####
# Function 
outlier.detection.zrange <- function(x) {
    zrange <- max(x) - min(x);
    zrange.matrix <- c(x, zrange);
    names(zrange.matrix) <- c(names(x), 'zrange');
    zrange.matrix;
    }


# 1. MEAN and SD
molecular.zrange.mean <- apply(molecular.mean.t, 1, outlier.detection.zrange);
molecular.zrange.mean.t <- data.frame(t(molecular.zrange.mean));
mean.zscore <- cbind(molecular.zrange.mean.t, fpkm.data$Symbol);
colnames(mean.zscore) <- c(colnames(molecular.zrange.mean.t), 'Symbol');

# 2. MEAN and SD excluding zero
molecular.zrange.mean.nonzero <- apply(molecular.mean.nonzero.t, 1, outlier.detection.zrange);
molecular.zrange.mean.nonzero.t <- data.frame(t(molecular.zrange.mean.nonzero));
mean.nonzero.zscore <- cbind(molecular.zrange.mean.nonzero.t, fpkm.data$Symbol);
colnames(mean.nonzero.zscore) <- c(colnames(molecular.zrange.mean.nonzero.t), 'Symbol');

# 3. TRIMMED MEAN and TRIMMED SD
molecular.zrange.trimmean <- apply(molecular.trimmean.t, 1, outlier.detection.zrange);
molecular.zrange.trimmean.t <- data.frame(t(molecular.zrange.trimmean));
trimmean.zscore <- cbind(molecular.zrange.trimmean.t, fpkm.data$Symbol);
colnames(trimmean.zscore) <- c(colnames(molecular.zrange.trimmean.t), 'Symbol');

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
molecular.zrange.trimmean.nonzero <- apply(molecular.trimmean.nonzero.t, 1, outlier.detection.zrange);
molecular.zrange.trimmean.nonzero.t <- data.frame(t(molecular.zrange.trimmean.nonzero));
trimmean.nonzero.zscore <- cbind(molecular.zrange.trimmean.nonzero.t, fpkm.data$Symbol);
colnames(trimmean.nonzero.zscore) <- c(colnames(molecular.zrange.trimmean.nonzero.t), 'Symbol');

# 5. MEDIAN and MAD
molecular.zrange.median <- apply(molecular.median.t, 1, outlier.detection.zrange);
molecular.zrange.median.t <- data.frame(t(molecular.zrange.median));
median.zscore <- cbind(molecular.zrange.median.t, fpkm.data$Symbol);
colnames(median.zscore) <- c(colnames(molecular.zrange.median.t), 'Symbol');

# 6. MEDIAN and MAD excluding zero
molecular.zrange.median.nonzero <- apply(molecular.median.nonzero.t, 1, outlier.detection.zrange);
molecular.zrange.median.nonzero.t <- data.frame(t(molecular.zrange.median.nonzero));
median.nonzero.zscore <- cbind(molecular.zrange.median.nonzero.t, fpkm.data$Symbol);
colnames(median.nonzero.zscore) <- c(colnames(molecular.zrange.median.nonzero.t), 'Symbol');




### Calculate the kmean fraction #####
# Function 
outlier.detection.kmean <- function(x) {
    if (1 == length(unique(as.numeric(x)))) {
        fraction <- NA;
        } 
    else {
        cluster.one <- length(x[x == 1]);
        cluster.two <- length(x[x == 2]);
        cluster.sum <- cluster.one + cluster.two;
        smaller.value <- min(cluster.one, cluster.two);
        fraction <- round(smaller.value/cluster.sum, digit = 4);
        }
    fraction.matrix <- c(x, fraction);
    names(fraction.matrix) <- c(names(x), 'fraction');
    fraction.matrix;
    }

# 7. KMEAN fraction
molecular.fraction.kmean <- apply(molecular.kmean.t, 1, outlier.detection.kmean);
molecular.fraction.kmean.t <- data.frame(t(molecular.fraction.kmean));
kmean.fraction <- cbind(molecular.fraction.kmean.t, fpkm.data$Symbol);
colnames(kmean.fraction) <- c(colnames(molecular.fraction.kmean.t), 'Symbol');

# 8. KMEAN fraction excluding zero
molecular.fraction.kmean.nonzero <- apply(molecular.kmean.nonzero.t, 1, outlier.detection.kmean);
molecular.fraction.kmean.nonzero.t <- data.frame(t(molecular.fraction.kmean.nonzero));
kmean.nonzero.fraction <- cbind(molecular.fraction.kmean.nonzero.t, fpkm.data$Symbol);
colnames(kmean.nonzero.fraction) <- c(colnames(molecular.fraction.kmean.nonzero.t), 'Symbol');




## Final gene-wise matrix #####
gene.zrange.fraction <- cbind(mean.zscore$zrange,
                     mean.nonzero.zscore$zrange,
                     median.zscore$zrange,
                     median.nonzero.zscore$zrange,
                     trimmean.zscore$zrange,
                     trimmean.nonzero.zscore$zrange,
                     kmean.fraction$fraction,
                     kmean.nonzero.fraction$fraction,
                     data.frame(fpkm.data$Symbol));
rownames(gene.zrange.fraction) <- rownames(molecular.data);
colnames(gene.zrange.fraction) <- c('zrange.mean', 'zrange.mean.nonzero', 'zrange.median',
                           'zrange.median.nonzero', 'zrange.trimmean', 'zrange.trimmean.nonzero',
                           'fraction.kmean', 'fraction.kmean.nonzero', 'Symbol');

```


## 3. Function for checking whether the outliers are highly abundant or lowly abundant
```{r}
### Check whether the outliers are highly abundant or lowly abundant #####
# Function 
# Show the max or min value
zrange.direction <- function (x) {
    num.x <- as.numeric(x); #names(x) will need for final output
    if (is.na(max(x)) | is.infinite(max(num.x))) {
        max.min <- NA;
        }
    else {
        if (abs(max(num.x)) > abs(min(num.x))) {
            max.min <- max(num.x);
            }
        else if (abs(max(num.x)) < abs(min(num.x))) {
            max.min <- min(num.x);
            } 
        else {
            max.min <- NA;
            }
        } 
    max.min;
    }

# Check with Mean/SD z-score 
# - if direction < 0, the gene is lowly abundant
# - if direction > 0, the gene is highly abundant
#  MEAN and SD
direction.mean <- apply(mean.zscore[,patient.part], 1, zrange.direction);
mean.zscore.direction <- cbind(mean.zscore, direction.mean);


### Check whether the outliers are highly abundant or lowly abundant #####
# Function 
# Highly abundant gene : 1
# Lowly abundant gene : -1
# NA : NA
outlier.direction <- function (x) {
    if (is.na(x)) {
        return(NA);
        }
    else if (x > 0) {
        return(1);
        }
    else if (x < 0) {
        return(-1);
        }
    else {
        return(0);
        }
    }

direction <- apply(data.frame(direction.mean), 1, outlier.direction);
gene.zrange.fraction.direction <- cbind(gene.zrange.fraction, direction);
head(gene.zrange.fraction.direction);


```


## 4. Function for making patient-wise outlier matrix
```{r, fig.width=11, fig.height=7}

### Make patient-wise outlier matrix  #####
# Function 
# Mark the patients over/under threshold
outlier.sample <- function(x, zscore) { 
    outlier.count <- NA;
    x.num <- as.numeric(x); #names(x) will need for final output
    for (i in 1: length(x)) {
        if (is.na(x.num[i]) | is.infinite(x.num[i])) {
            outlier.count[i] <- 0;
            } 
        else if (x.num[i] > zscore) {
            outlier.count[i] <- 1;
            } 
        else if (x.num[i] < -zscore) {
            outlier.count[i] <- -1;
            } 
        else {
            outlier.count[i] <- 0;
            }
        }
    names(outlier.count) <- names(x);
    outlier.count;
    }


### Make patient-wise outlier matrix  #####
# Function 
# Calculate the sum of outliers per patient
outlier.sample.sum <- function(x) {
    x.num <- as.numeric(x); #names(x) will need for final output 
    high.number <- length(x.num[x.num == 1]) ;
    low.number <- length(x.num[x.num == -1]) ;
    number.outlier <- high.number + low.number;
    sample.outlier <- c(number.outlier, high.number, low.number, x);
    names(sample.outlier) <- c('sum', 'high', 'low', names(x));
    sample.outlier;
    }



### Use threshold p-value < 0.05 (z-score > 1.96 / z-score < -1.96) ###
## Mark the patients over/under threshold
# p-value
p.value <- qnorm(0.05/2, lower.tail=FALSE);
p.value;

# 1. MEAN and SD
pvalue.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.mean.t <- data.frame(t(pvalue.mean));

# 2. MEAN and SD excluding zero
pvalue.mean.nonzero <- apply(mean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.mean.nonzero.t <- data.frame(t(pvalue.mean.nonzero));

# 3. TRIMMED MEAN and TRIMMED SD
pvalue.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.trimmean.t <- data.frame(t(pvalue.trimmean));

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
pvalue.trimmean.nonzero <- apply(trimmean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.trimmean.nonzero.t <- data.frame(t(pvalue.trimmean.nonzero));

# 5. MEDIAN and MAD
pvalue.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.median.t <- data.frame(t(pvalue.median));

# 6. MEDIAN and MAD excluding zero
pvalue.median.nonzero <- apply(median.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
pvalue.median.nonzero.t <- data.frame(t(pvalue.median.nonzero));


## Calculate the sum of outliers per patient
# 1. MEAN and SD
pvalue.mean.sum <- apply(pvalue.mean.t, 2, outlier.sample.sum);

# 2. MEAN and SD excluding zero
pvalue.mean.nonzero.sum <- apply(pvalue.mean.t, 2, outlier.sample.sum);

# 3. TRIMMED MEAN and TRIMMED SD
pvalue.trimmean.sum <- apply(pvalue.trimmean.t, 2, outlier.sample.sum);

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
pvalue.trimmean.nonzero.sum <- apply(pvalue.trimmean.nonzero.t, 2, outlier.sample.sum);

# 5. MEDIAN and MAD
pvalue.median.sum <- apply(pvalue.median.t, 2, outlier.sample.sum);
pvalue.median.sum[1:3,];
hist(pvalue.median.sum[1,],
     main = 'number of outliers (median): p-value < 0.05',
     xlab = 'number of outliers');

# 6. MEDIAN and MAD excluding zero
pvalue.median.nonzero.sum <- apply(pvalue.median.nonzero.t, 2, outlier.sample.sum);




### Use threshold Bonferroni < 0.05  ###
## Mark the patients over/under threshold
# Bonferroni correction
bonferroni.threshold <- 0.05 / (length(patient.part) * nrow(molecular.data));
bonferroni <- qnorm(bonferroni.threshold/2, lower.tail=FALSE);
bonferroni;

# 1. MEAN and SD
bon.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.mean.t <- data.frame(t(bon.mean));

# 2. MEAN and SD excluding zero
bon.mean.nonzero <- apply(mean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.mean.nonzero.t <- data.frame(t(bon.mean.nonzero));

# 3. TRIMMED MEAN and TRIMMED SD
bon.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.trimmean.t <- data.frame(t(bon.trimmean));

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
bon.trimmean.nonzero <- apply(trimmean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.trimmean.nonzero.t <- data.frame(t(bon.trimmean.nonzero));

# 5. MEDIAN and MAD
bon.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.median.t <- data.frame(t(bon.median));

# 6. MEDIAN and MAD excluding zero
bon.median.nonzero <- apply(median.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
bon.median.nonzero.t <- data.frame(t(bon.median.nonzero));


## Calculate the sum of outliers per patient
# 1. MEAN and SD
bon.mean.sum <- apply(bon.mean.t, 2, outlier.sample.sum);

# 2. MEAN and SD excluding zero
bon.mean.nonzero.sum <- apply(bon.mean.nonzero.t, 2, outlier.sample.sum);

# 3. TRIMMED MEAN and TRIMMED SD
bon.trimmean.sum <- apply(bon.trimmean.t, 2, outlier.sample.sum);

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
bon.trimmean.nonzero.sum <- apply(bon.trimmean.nonzero.t, 2, outlier.sample.sum);

# 5. MEDIAN and MAD
bon.median.sum <- apply(bon.median.t, 2, outlier.sample.sum);
bon.median.sum[1:3,]
hist(bon.median.sum[1,],
     main = 'number of outliers (median): p-value < 0.05/(number.gene*number.patient)',
     xlab = 'number of outliers');

# 6. MEDIAN and MAD excluding zero
bon.median.nonzero.sum <- apply(bon.median.nonzero.t, 2, outlier.sample.sum);





### Use threshold p-threshold-adjusted = p-threshold / (number.patient x number.gene x number.methods) ###
## Mark the patients over/under threshold
# number of methods
methods.num <- c('mean', 'mean.nonzero', 'trimmean', 'trimmean.nonzero', 'median', 'median.nonzero', 'kmean', 'kmean.nonzero');
adjust.p.threshold <- 0.05 / (length(patient.part) * nrow(molecular.data) * length(methods.num));
adjust.p <- qnorm(adjust.p.threshold/2, lower.tail=FALSE);
adjust.p;

# 1. MEAN and SD
adjust.p.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.mean.t <- data.frame(t(adjust.p.mean));

# 2. MEAN and SD excluding zero
adjust.p.mean.nonzero <- apply(mean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.mean.nonzero.t <- data.frame(t(adjust.p.mean.nonzero));

# 3. TRIMMED MEAN and TRIMMED SD
adjust.p.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.trimmean.t <- data.frame(t(adjust.p.trimmean));

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
adjust.p.trimmean.nonzero <- apply(trimmean.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.trimmean.nonzero.t <- data.frame(t(adjust.p.trimmean.nonzero));

# 5. MEDIAN and MAD
adjust.p.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.median.t <- data.frame(t(adjust.p.median));

# 6. MEDIAN and MAD excluding zero
adjust.p.median.nonzero <- apply(median.nonzero.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
adjust.p.median.nonzero.t <- data.frame(t(adjust.p.median.nonzero));


## Calculate the sum of outliers per patient
# 1. MEAN and SD
adjust.p.mean.sum <- apply(adjust.p.mean.t, 2, outlier.sample.sum);

# 2. MEAN and SD excluding zero
adjust.p.mean.nonzero.sum <- apply(adjust.p.mean.nonzero.t, 2, outlier.sample.sum);

# 3. TRIMMED MEAN and TRIMMED SD
adjust.p.trimmean.sum <- apply(adjust.p.trimmean.t, 2, outlier.sample.sum);

# 4. TRIMMED MEAN and TRIMMED SD excluding zero
adjust.p.trimmean.nonzero.sum <- apply(adjust.p.trimmean.nonzero.t, 2, outlier.sample.sum);

# 5. MEDIAN and MAD
adjust.p.median.sum <- apply(adjust.p.median.t, 2, outlier.sample.sum);
adjust.p.median.sum[1:3,];
hist(adjust.p.median.sum[1,],
     main = 'number of outliers (median): p-value < 0.05/(number.gene*number.patient)',
     xlab = 'number of outliers');

# 6. MEDIAN and MAD excluding zero
adjust.p.median.nonzero.sum <- apply(adjust.p.median.nonzero.t, 2, outlier.sample.sum);



```


## 5. File check - match the name of patients
```{r}

# Match the name of patients
#  - if patient set is not same, error will occur.
#  x: FPKM data
#  y: z-score data
patient.match.check <- function(x, y) {
    tryCatch(
        expr = {
            colnames(x) == colnames(y);
            message('Same patient set!') ;
            },
        warning = function(e){
            stop('Patient does not match. Check the data!');
            }
        )
    }



data.list <- list(mean.zscore,
                  mean.nonzero.zscore,
                  median.zscore,
                  median.nonzero.zscore,
                  trimmean.zscore,
                  trimmean.nonzero.zscore,
                  kmean.fraction,
                  kmean.nonzero.fraction,
                  pvalue.mean.sum,
                  pvalue.mean.nonzero.sum,
                  pvalue.trimmean.sum,
                  pvalue.trimmean.nonzero.sum,
                  pvalue.median.sum,
                  pvalue.median.nonzero.sum,
                  bon.mean.sum,
                  bon.mean.nonzero.sum,
                  bon.trimmean.sum,
                  bon.trimmean.nonzero.sum,
                  bon.median.sum,
                  bon.median.nonzero.sum,
                  adjust.p.mean.sum,
                  adjust.p.mean.nonzero.sum,
                  adjust.p.trimmean.sum,
                  adjust.p.trimmean.nonzero.sum,
                  adjust.p.median.sum,
                  adjust.p.median.nonzero.sum);

for (i in 1:length(data.list)) {
    patient.match.check(fpkm.data[,patient.part], data.list[[i]][,patient.part]);
    }


```


## 6. Function for making heatmap of z-score and FPKM
```{r, fig.width=11, fig.height=10}
### Make heatmap for Top 200 genes
# input variable : the file with z-score and the range of z-score from each methods

# Make a heatmap in z-score space
outlier.heatmap.zscore <- function(x) {
    order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
    order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
    order.num.symbol <- cbind(order.num, order$Symbol);
    colnames(order.num.symbol) <- colnames(order);
    rownames(order.num.symbol) <- rownames(order);
    order.na <- na.omit(order.num.symbol);
    order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
    zscore.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = order.na.inf[1:200, 1:(length(x)-2)],
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = order.na.inf$Symbol,
        xaxis.cex = 0.3,
        main = paste('The z-score of top 200 genes calculated using',
                     sub('.{7}$', '', substitute(x))),
        main.cex = 1.5,
        grid.col = FALSE,
        print.colour.key = TRUE,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('red4', 'white', 'dodgerblue4'),
        colour.centering.value = 0,
        at = seq(-5,5,0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    zscore.heat;
    }

outlier.heatmap.zscore(median.zscore);


#Make a heatmap in FPKM space
# x : z-score matrix
# y : raw FPKM matrix
outlier.heatmap.fpkm <- function(x, y) {
    order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
    order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
    order.num.symbol <- cbind(order.num, order$Symbol);
    colnames(order.num.symbol) <- colnames(order);
    rownames(order.num.symbol) <- rownames(order);
    order.na <- na.omit(order.num.symbol);
    order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
    fpkm <- y[rownames(y) %in% rownames(order.na.inf)[1:200],];
    fpkm.log <- log10((fpkm[ , 1:(length(fpkm)-1)])+1)
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = fpkm.log,
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = fpkm$Symbol,
        xaxis.cex = 0.3,
        main = paste('FPKM value of top 200 genes calculated using',
                     sub('.{7}$', '', substitute(x)),
                     'in log10 space'),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = TRUE,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('white', 'dodgerblue4'),
        at = seq(0,1,0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

outlier.heatmap.fpkm(median.zscore, fpkm.data);

```



## 7. Function for making Waterfall plot 
```{r, fig.width=10, fig.height=6}

#Make multiplot for z-score and FPKM value
# x : z-score matrix
# y : raw FPKM matrix
# z : number of plot

outlier.waterfallplot <- function(x, y, plot.num = 1, kmean = FALSE, threshold = FALSE) {
    if (kmean) {
        order <- x[order(x[,(length(x)-1)], decreasing = FALSE),];
        z.color = 'black';
        }
    else {
        order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
        }
    order.na <- na.omit(order);
    order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
    for (i in 1:plot.num ) {
        if (kmean) {
            patient.part <- 1: (length(order.na.inf)-2);
            a <- t(order.na.inf[i,patient.part]);
            z.gene <- as.numeric(order.na.inf[i,patient.part]);
            row.a <- data.frame(row.names(a));
            gene.a <- cbind(row.a, z.gene);
            colnames(gene.a) <- c('patient', 'gene');
            sum.one <- sum(gene.a$gene == 1)
            sum.two <- sum(gene.a$gene == 2)
            if (sum.one < sum.two) {
                fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                    formula = gene ~ patient,
                    data = gene.a,
                    main = paste(order.na.inf$Symbol[i],
                                 'calculated using',
                                 sub('.{9}$', '', substitute(x))),
                    main.cex = 1.5,
                    ylab.lab = 'Z-Score',
                    yaxis.cex = 1,
                    ylab.cex = 1,
                    xaxis.tck = 0.2,
                    xlab.lab = 'Patient',
                    xaxis.rot = 90,
                    xaxis.cex = 0.3,
                    xlab.cex = 1,
                    yaxis.tck = 1,
                    yaxis.fontface = 'bold',
                    sample.order = 'increasing'
                    );
                }
            else {
                fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                    formula = gene ~ patient,
                    data = gene.a,
                    main = paste(order.na.inf$Symbol[i],
                                 'calculated using',
                                 sub('.{9}$', '', substitute(x))),
                    main.cex = 1.5,
                    ylab.lab = 'Z-Score',
                    yaxis.cex = 1,
                    ylab.cex = 1,
                    xaxis.tck = 0.2,
                    xlab.lab = 'Patient',
                    xaxis.rot = 90,
                    xaxis.cex = 0.3,
                    xlab.cex = 1,
                    yaxis.tck = 1,
                    yaxis.fontface = 'bold',
                    sample.order = 'decreasing'
                    );
                }
            }
        else {
            patient.part <- 1: (length(order.na.inf)-2);
            a <- t(order.na.inf[i,patient.part]);
            z.gene <- as.numeric(order.na.inf[i,patient.part]);
            row.a <- data.frame(row.names(a));
            gene.a <- cbind(row.a, z.gene);
            colnames(gene.a) <- c('patient', 'gene');
            z.gene.order <- z.gene[order(z.gene, decreasing =TRUE)];
            if (threshold) {
                z.color <- NA
                for (k in 1: (length(order.na.inf)-2)) {
                    if (z.gene.order[k] > threshold) {
                        z.color[k] <- 'red';
                        } 
                    else {
                      z.color[k] <- 'black';
                        }
                    }
                }
            else {
              z.color <- 'black';
                }
            fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ patient,
                data = gene.a,
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{7}$', '', substitute(x))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                yaxis.fontface = 'bold',
                col = z.color,
                sample.order = 'decreasing'
                );
            }
            
        fpkm.gene <- as.numeric(y[rownames(order.na.inf)[i],patient.part]);
        fpkm.b <- cbind(row.a, fpkm.gene);
        colnames(fpkm.b) <- c('patient', 'gene');
        nonzero.fpkm <- round(sum(ifelse(fpkm.b$gene == 0, 0, 1))/length(patient.part)*100, 2);
        fpkm.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = fpkm.b,
            main = order.na.inf$Symbol[i],
            main.cex = 1.5,
            ylab.lab = 'FPKM',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            yaxis.fontface = 'bold',
            col = z.color,
            sample.order = 'decreasing'
            );
        if (kmean) {
            final.plot <- BoutrosLab.plotting.general:::create.multiplot(
                plot.objects = list(fpkm.bar, fraction.bar),
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{9}$', '', substitute(x)),
                             'z-score threshold =',
                             round(threshold, digits = 2)),
                xlab.label = 'Patient',
                ylab.label = c('Z-score', 'FPKM'),
                y.relation = 'free',
                main.cex = 1.3,
                xaxis.cex = 0.3,
                yaxis.cex = 0.7,
                ylab.cex = 1,
                xlab.cex = 1,
                xaxis.rot = 90,
                xaxis.tck = 0.2,
                key = list(
                    title = expression(underline('Fraction of patient')),
                    text = list(
                        lab = paste(as.character(nonzero.fpkm),'%'),
                        cex = 1.1,
                        col = 'black'
                        ),
                    x = 0.75,
                    y = 0.4,
                    padding.text = 3,
                    columns = 1
                    ),
                resolution = 50
                );
            }
        else {
            final.plot <- BoutrosLab.plotting.general:::create.multiplot(
                plot.objects = list(fpkm.bar, fraction.bar),
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{9}$', '', substitute(x)),
                             'z-score threshold =',
                             round(threshold, digits = 2)),
                xlab.label = 'Patient',
                ylab.label = c('Z-score', 'FPKM'),
                y.relation = 'free',
                main.cex = 1.3,
                xaxis.cex = 0.3,
                yaxis.cex = 0.7,
                ylab.cex = 1,
                xlab.cex = 1,
                xaxis.rot = 90,
                xaxis.tck = 0.2,
                key = list(
                    title = expression(underline('Fraction of patient')),
                    text = list(
                        lab = paste(as.character(nonzero.fpkm),'%'),
                        cex = 1.1,
                        col = 'black'
                        ),
                    x = 0.75,
                    y = 0.4,
                    padding.text = 3,
                    columns = 1
                    ),
                resolution = 50
                );
            }
        return(final.plot);
        }
    }


### Use threshold p-value < 0.05 (z-score > 1.96 / z-score < -1.96) ###
## Mark the patients over/under threshold
# p-value 
p.value <- qnorm(0.05/2, lower.tail=FALSE);
outlier.waterfallplot(median.zscore, fpkm.data, plot.num = 1, threshold = p.value);


### Use threshold Bonferroni < 0.05  ###
## Mark the patients over/under threshold
# Bonferroni correction 
bon <- 0.05/length(patient.part);
bon.zscore <- qnorm(bon/2, lower.tail=FALSE);
outlier.waterfallplot(median.zscore, fpkm.data, plot.num = 1, threshold = bon.zscore);


### Use threshold p-threshold-adjusted = p-threshold / (number.patient x number.methods) ###
## Mark the patients over/under threshold
# number of methods
methods.num <- c('mean', 'mean.nonzero', 'trimmean', 'trimmean.nonzero', 'median', 'median.nonzero');
adjust.p.threshold <- 0.05/(length(patient.part)*length(methods.num));
adjust.p.zscore <- qnorm(adjust.p.threshold/2, lower.tail=FALSE);
outlier.waterfallplot(median.zscore, fpkm.data, plot.num = 1, threshold = adjust.p.zscore);


### K-mean matrix in waterfall plot
outlier.waterfallplot(kmean.fraction, fpkm.data, plot.num = 1, kmean = TRUE);


```

## 8. Function for checking out the technical problem
```{r, fig.width=11, fig.height=10}

### Make heatmap for the fraction of genes enriched on each chromosome
#   Show the list of patients with chromosome and the fraction which show the low enrichment (< 20%)
# input variable 
#   molecular.data : check the number of the genes (FPKM > 0)


outlier.technical.problem <- function(x) {
    gene.list.all <- rownames(x);
    gene.list.all.sub <- substr(gene.list.all, 1, 15);
    ensembl.all <- biomaRt:::useEnsembl(biomart = 'ensembl', 
                                        dataset = 'hsapiens_gene_ensembl', 
                                        mirror = 'uswest');
    ensembl.all <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl.all);
    gene.position.all <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
                                                        'start_position', 'end_position', 'band'),
                                         filters = 'ensembl_gene_id', 
                                         values = gene.list.all.sub, 
                                         mart = ensembl.all);
    gene.all <- subset(fpkm.data, gene.list.all.sub %in% gene.position.all$ensembl_gene_id);
    gene.position.order.all <- gene.position.all[order(as.numeric(gene.position.all$chromosome_name),
                                                       as.numeric(gene.position.all$start_position), 
                                                       decreasing = FALSE),];
    gene.biomart.fpkm.all <- gene.all[match(gene.position.order.all$ensembl_gene_id, 
                                            substr(rownames(gene.all), 1, 15)),];
    chr.ord.all <- cbind(gene.biomart.fpkm.all, 
                         gene.position.order.all[,3:5]);
    
    chr.matrix <- data.frame();
    for (i in 1 : 22) {
        chr <- chr.ord.all[chr.ord.all$chromosome_name == i, ];
        chr.num <- nrow(chr);
        for (k in 1 : length(patient.part)) {
            gene.num <- sum(chr[, k] != 0);
            chr.matrix[i,k] <- gene.num / chr.num;
            }
        }
    colnames(chr.matrix) <- colnames(x);
    
    chr.fraction.heat <- BoutrosLab.plotting.general:::create.heatmap(
       x = chr.matrix,
       clustering.method = 'none',
       cluster.dimensions = 'none',
       yaxis.lab = NA,
       yaxis.cex = 0.3,
       xaxis.lab = paste('chr', rownames(chr.matrix)),
       xaxis.cex = 1,
       main = 'The fraction of genes enriched on each chromosome',
       main.cex = 1.5,
       grid.col = FALSE,
       print.colour.key = TRUE,
       yaxis.tck = 0.1,
       xaxis.tck = 0.1,
       colour.scheme = c('white','red4'),
       colour.centering.value = 0.5,
       at = seq(0,1,0.001),
       colourkey.cex = 1,
       resolution = 300,
       );
    
    abnormal.matrix <- data.frame();
    for (i in 1 : 22) {
        for (k in 1 : length(patient.part)) {
            if (chr.matrix[i, k] < 0.2) {
                abnormal.chr <- cbind(colnames(chr.matrix)[k], paste('chr', rownames(chr.matrix)[i]), chr.matrix[i, k]);
                abnormal.matrix <- rbind(abnormal.matrix, abnormal.chr);
                }
            }
        }
    
    if (length(abnormal.matrix) > 0) {
    colnames(abnormal.matrix) <- c('patient', 'chr', 'fraction');
    abnormal.matrix$fraction <- round(as.numeric(abnormal.matrix$fraction), digits = 3);
        }
    
    list(abnormal.pattern = abnormal.matrix, fraction.heatmap = chr.fraction.heat);
    }

outlier.technical.problem(molecular.data);


```

## 9. Function for making heatmap of each chromosome position
```{r, fig.width=11, fig.height=10}

### Make heatmap for chromosomal position
# input variable 
#   x: the file with z-score and the range of z-score from each methods
#   chr.num: 24 for women (No Y chromosome)
#            25 for men 


outlier.position <- function(x, chr.num = 24) {
    order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
    order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
    order.num.symbol <- cbind(order.num, order$Symbol);
    colnames(order.num.symbol) <- colnames(order);
    rownames(order.num.symbol) <- rownames(order);
    order.na <- na.omit(order.num.symbol);
    order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
    patient.part <- 1: (length(order.na.inf)-2);
    gene.list.all <- rownames(order.na.inf);
    gene.list.all.sub <- substr(gene.list.all, 1, 15);
    ensembl.all <- biomaRt:::useEnsembl(biomart = 'ensembl', 
                                        dataset = 'hsapiens_gene_ensembl', 
                                        mirror = 'uswest');
    ensembl.all <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl.all);
    gene.position.all <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
                                                        'start_position', 'end_position', 'band'),
                                         filters = 'ensembl_gene_id', 
                                         values = gene.list.all.sub, 
                                         mart = ensembl.all);
    gene.all <- subset(order.na.inf, gene.list.all.sub %in% gene.position.all$ensembl_gene_id);
    gene.position.order.all <- gene.position.all[order(as.numeric(gene.position.all$chromosome_name),
                                                       as.numeric(gene.position.all$start_position), 
                                                       decreasing = FALSE),];
    gene.biomart.fpkm.all <- gene.all[match(gene.position.order.all$ensembl_gene_id, 
                                            substr(rownames(gene.all), 1, 15)),];
    chr.position <- c(3, 4, 5); # chromosome_name, start_position, end_position
    chr.ord.all <- cbind(gene.biomart.fpkm.all, 
                         gene.position.order.all[,colnames(gene.position.order) %in% c('chromosome_name', 'start_position', 'end_position')]);
    chr.ord.na <- na.omit(chr.ord.all);
    chr.name <- c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', 
                  '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', 
                  '21', '22', 'MT', 'X', 'Y');
    chr.ord.na.numeric <- chr.ord.na;
    for (i in 1 : nrow(chr.ord.na.numeric)){
        if('MT' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '23';
            }
        if('X' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '24';
            }
        if('Y' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '25';
            }
        }
    for (i in 1 : chr.num) {
        heat <- BoutrosLab.plotting.general:::create.heatmap(
            x = chr.ord.na.numeric[chr.ord.na.numeric$chromosome_name == i, patient.part],
            clustering.method = 'ward.D2',
            cluster.dimensions = 'row',
            main = paste('Chr', chr.name[i], 
                         '- the z-score of all genes calculated using',
                         sub('.{7}$', '', substitute(x))),
            main.cex = 1.5,
            colourkey.cex = 1,
            scale.data = FALSE,
            colour.scheme = c('red4', 'white', 'dodgerblue4'),
            colour.centering.value = 0,
            at = seq(-5,5,0.001),
            yaxis.lab = NA,
            yaxis.cex = 0.3,
            rows.distance.method = 'euclidean',
            resolution = 500
            );
        return(heat);
        }
    }

outlier.position(median.zscore, chr.num = 25);


```

 
## 10. Function for ranking outliers 
```{r, fig.width=12, fig.height=11}
### Rank each methods #####
# Function 
outlier.rank <- function(x) {
    methods <- c('zrange.mean','zrange.mean.nonzero','zrange.median','zrange.median.nonzero',
                 'zrange.trimmean', 'zrange.trimmean.nonzero','fraction.kmean', 'fraction.kmean.nonzero');
    rank.matrix <- NULL;
    # Give rank for each methods based on z-score range/fraction of kmean
    for (i in 1:6) {
        methods.column <- methods[i];
        rank.methods <- rank(-x[,methods.column], ties.method = 'max', na.last = 'keep');
        rank.matrix <- cbind(rank.matrix, rank.methods);
        }
    for (i in 7:8) {
        methods.column <- methods[i];
        rank.methods <- rank(x[,methods.column], ties.method = 'max', na.last = 'keep');
        rank.matrix <- cbind(rank.matrix, rank.methods);
        }
    rank.matrix <- cbind(rank.matrix, x[,9:10]);
    rownames(rank.matrix) <-rownames(x);
    colnames(rank.matrix) <-colnames(x);
    rank.matrix <- data.frame(rank.matrix);
    }

# data.rank <- outlier.rank(gene.zrange.fraction.direction);


### Rank product to determine Top ranked genes #####
# Function 
# x: ranked matrix
# NA.number = Number of methods with non-NA should be more than assigned number
outlier.rank.product <- function(x, NA.number = 0) {
    rank <- as.numeric(x[1:8]);
    num <- length(which(!is.na(rank)));
    if (NA.number >= num) {
        NA;
        }
    else {
        prod(rank, na.rm = TRUE) / (num^num);
        }
    }

# # NA.number = 6 : at least 7 methods have ranked value (Only allowed one NA)
# rank.product.6 <- apply(data.rank, 1, outlier.rank.product, NA.number = 6);
# gene.rank.6 <- cbind(data.rank, rank.product.6);
# gene.rank.order.6 <- gene.rank.6[order(gene.rank.6$rank.product, decreasing = FALSE),];
gene.rank.order.6$Symbol[1:1000];
# 
# # NA.number = 5 : at least 6 methods have ranked value (Allowed two NA)
# rank.product.5 <- apply(data.rank, 1, outlier.rank.product, NA.number = 5);
# gene.rank.5 <- cbind(data.rank, rank.product.5);
# gene.rank.order.5 <- gene.rank.5[order(gene.rank.5$rank.product, decreasing = FALSE),];
# gene.rank.order.5$Symbol[1:1000];


### Heatmap of TOP ranked genes ###
# Top 1000 genes in FPKM space
outlier.heatmap.rank <- function(x) {
    fpkm <- fpkm.data[rownames(fpkm.data) %in% rownames(x)[1:1000],];
    fpkm.log <- log10((fpkm[ , 1:(length(fpkm)-1)])+1);
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = fpkm.log,
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = fpkm$Symbol,
        xaxis.cex = 0.2,
        main = paste('FPKM value of top 1000 ranked genes in log10 space'),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = TRUE,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('white', 'dodgerblue4'),
        at = seq(0,1,0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

# NA.number = 6 : at least 7 methods have ranked value (Only allowed one NA)
outlier.heatmap.rank(gene.rank.order.6);


# Top 1000 genes in z-score space
outlier.heatmap.rank.zscore.rank <- function(x, y) {
    zscore.rank <- x[rownames(x) %in% rownames(y)[1:1000], ];
    zscore.rank.order.na <- na.omit(zscore.rank);
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = zscore.rank.order.na[, patient.part],
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = zscore.rank.order.na$Symbol,
        xaxis.cex = 0.2,
        main = paste('The z-score of top 1000 ranked genes calculated using',
                     sub('.{7}$', '', substitute(x))),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = TRUE,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('red4', 'white', 'dodgerblue4'),
        colour.centering.value = 0,
        at = seq(-5,5,0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

# NA.number = 6 : at least 7 methods have ranked value (Only allowed one NA)
outlier.heatmap.rank.zscore.rank(median.zscore, gene.rank.order.6);


 
### Count the number of outliers (top1000) per patients ###
# x: ranked gene data (gene.rank.order.6)
# y: patient-wise outlier matrix
patient.outlier <- function(x, y) {
    x.1000 <- x[1:1000,];
    y.gene <- y[4:nrow(y),];
    y.1000 <- y.gene[rownames(y.gene) %in% rownames(x.1000),];
    apply(y.1000, 2, sum);
    }

patient.median.adjust.p.sum <- patient.outlier(gene.rank.order.6, adjust.p.median.sum);
hist(patient.median.adjust.p.sum,
     main = 'number of outliers per patient: adjust.p-value < 0.05',
     xlab = 'number of outliers');

### Heatmap of outliers ordered by the number of outliers per patient ###
# x: matrix with the number of outliers per patients
# y: z-score data
# z: ranked gene data (gene.rank.order.6)

patient.order.outlier.heatmap <- function (x, y, z) {
    patient.order <- names(sort(x));
    zscore.rank <- y[rownames(y) %in% rownames(z)[1:1000],];
    zscore.rank.order <- zscore.rank[, c(match(patient.order, colnames(zscore.rank)), length(y))];
    zscore.rank.order.na <- na.omit(zscore.rank.order);
    zscore.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = zscore.rank.order.na[,patient.part],
        clustering.method = 'none',
        cluster.dimensions = 'none',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = zscore.rank.order.na$Symbol,
        xaxis.cex = 0.3,
        main = paste('The z-score of top 1000 genes calculated using',
                     sub('.{7}$', '', substitute(y)),
                     ' - ordered patient'),
        main.cex = 1.5,
        grid.col = FALSE,
        print.colour.key = TRUE,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('red4', 'white', 'dodgerblue4'),
        colour.centering.value = 0,
        at = seq(-5,5,0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'none',
        cols.distance.method = 'none'
        );
    zscore.heat; 
    }

patient.order.outlier.heatmap(patient.median.adjust.p.sum, median.zscore, gene.rank.order.6);


```


## 11. Multi-Waterfall plot with clinical data
```{r, fig.width=14, fig.height=15.05, warning = FALSE}
### Make covariates ###

# Match the patients between fpkm.data vs clinical.data
clinical.data$Patient.ID <- gsub('-', '.', clinical.data$Patient.ID);
clinical.data.match <- clinical.data[clinical.data$Patient.ID %in% colnames(fpkm.data[,patient.part]),];
duplicate.sample <- clinical.data.match[duplicated(clinical.data.match$Patient.ID),]$Sample.ID;
clinical.data.match.dup <- clinical.data.match[clinical.data.match$Sample.ID != duplicate.sample,];
clinical.outcome <- clinical.data.match.dup[match(colnames(fpkm.data[,patient.part]), clinical.data.match.dup$Patient.ID),];


## 1. ISUP GG ##
primary.gs <- clinical.outcome$Gleason.pattern.primary;
secondary.gs <- clinical.outcome$Gleason.pattern.secondary;
final.gs <- primary.gs + secondary.gs;
isup <- data.frame();
for (i in 1:length(primary.gs)) {
    if (final.gs[i] <= 6) {
        isup[i,1] <- 1;
        }
    else if (3 == primary.gs[i] & 4 == secondary.gs[i]) {
        isup[i,1] <- 2;
        }
    else if (4 == primary.gs[i] & 3 == secondary.gs[i]) {
        isup[i,1] <- 3;
        }
    else if (8 == final.gs[i]) {
        isup[i,1] <- 4;
        }
    else if (final.gs[i] >= 9) {
        isup[i,1] <- 5;
        }
    }

## 2. PSA ##
# 0~1 / 1~10 / 10~100 / 100<
psa <- clinical.outcome$Psa.most.recent.results;
psa.stage <- data.frame();
for (i in 1:length(psa)) {
    if (is.na(psa[i])) {
       psa.stage[i,1] <- 6;
      }
    else if (psa[i] <= 1) {
        psa.stage[i,1] <- 7;
        }
    else if (psa[i] > 1 & psa[i] <= 10) {
        psa.stage[i,1] <- 8;
        }
    else if (psa[i] > 10 & psa[i] <= 100) {
        psa.stage[i,1] <- 9;
        }
    else if (psa[i] > 100) {
        psa.stage[i,1] <- 10;
        }
    }

## 3. Age ##
# 40~49 / 50~59 / 60~69 / 70<
age <- clinical.outcome$Diagnosis.Age;
age.stage <- data.frame();
for (i in 1:length(age)) {
    if (is.na(age[i])) {
       age.stage[i,1] <- 6;
      }
    else if (age[i] < 50) {
        age.stage[i,1] <- 11;
        }
    else if (age[i] >= 50 & age[i] < 60) {
        age.stage[i,1] <- 12;
        }
    else if (age[i] >= 60 & age[i] < 70) {
        age.stage[i,1] <- 13;
        }
    else if (age[i] >= 70) {
        age.stage[i,1] <- 14;
        }
    }

## 4. Tumor Stage ##
# T2 / T3 / T4
grade <- clinical.outcome$American.Joint.Committee.on.Cancer.Tumor.Stage.Code;
grade.sub <- substr(grade, 1, 2);
grade.sub.stage <- data.frame();
for (i in 1:length(grade.sub)) {
    if (is.na(grade.sub[i])) {
       grade.sub.stage[i,1] <- 6;
        }
    else if ('T2' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 15;
        }
    else if ('T3' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 16;
        }
    else if ('T4' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 17;
        }
    }

### Make data.frame for heatmap ###
all.clinical <- cbind(isup, psa.stage, age.stage, grade.sub.stage);
rownames(all.clinical) <- colnames(fpkm.data[,patient.part]);


## Waterfall plot
# x: fpkm.data file
# a: gene.rank.order.6 - ranked gene file
# b: mean.zscore
# c: mean.nonzero.zscore
# d: trimmean.zscore
# e: trimmean.nonzero.zscore
# f: median.zscore
# g: median.nonzero.zscore
# h: kmean.fraction
# i: kmean.nonzero.fraction
# j: all.clinical - clinical data
# num: number of plots

outlier.multiwaterfallplot <- function(x, a, b, c, d, e, f, g, h, i, j, num = 1) {
   fpkm <- x[match(rownames(a), rownames(x)),];
   patient.part <- 1: (length(fpkm)-1);

    for (k in 1: num) {
        # FPKM plot
        fpkm.gene <- as.numeric(fpkm[k, patient.part]);
        fpkm.gene.t <- t(fpkm[k, patient.part]);
        row.fpkm.gene.t <- data.frame(row.names(fpkm.gene.t));
        fpkm.value <- cbind(row.fpkm.gene.t, fpkm.gene);
        colnames(fpkm.value) <- c('patient', 'gene');
        fpkm.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = fpkm.value,
            main = a$Symbol[k],
            main.cex = 1.5,
            ylab.lab = 'FPKM',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );
    
        # Mean plot
        b.order <- b[match(rownames(a), rownames(b)),];
        mean.gene <- as.numeric(b.order[k, patient.part]);
        mean.gene.t <- t(b.order[k, patient.part]);
        row.mean.gene.t <- data.frame(row.names(mean.gene.t));
        mean.value <- cbind(row.mean.gene.t, fpkm.gene, mean.gene);
        colnames(mean.value) <- c('patient', 'fpkm', 'gene');
        mean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = mean.value,
            main = paste(b.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(b))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (mean)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );      

        # Mean.nonzero plot
        c.order <- c[match(rownames(a), rownames(c)),];
        mean.nonzero.gene <- as.numeric(c.order[k, patient.part]);
        mean.nonzero.gene.t <- t(c.order[k, patient.part]);
        row.mean.nonzero.gene.t <- data.frame(row.names(mean.nonzero.gene.t));
        mean.nonzero.value <- cbind(row.mean.nonzero.gene.t, fpkm.gene, mean.nonzero.gene);
        colnames(mean.nonzero.value) <- c('patient', 'fpkm', 'gene');
        mean.nonzero.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = mean.nonzero.value,
            main = paste(c.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(c))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (mean.nonzero)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );       
              
        # Trimmean plot  
        d.order <- d[match(rownames(a), rownames(d)),];
        trimmean.gene <- as.numeric(d.order[k, patient.part]);
        trimmean.gene.t <- t(d.order[k, patient.part]);
        row.trimmean.gene.t <- data.frame(row.names(trimmean.gene.t));
        trimmean.value <- cbind(row.trimmean.gene.t, fpkm.gene, trimmean.gene);
        colnames(trimmean.value) <- c('patient', 'fpkm', 'gene');
        trimmean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = trimmean.value,
            main = paste(d.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(d))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (trimmed mean)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            ); 
    
        # Trimmean.nonzero plot
        e.order <- e[match(rownames(a), rownames(e)),];
        trimmean.nonzero.gene <- as.numeric(e.order[k, patient.part]);
        trimmean.nonzero.gene.t <- t(e.order[k, patient.part]);
        row.trimmean.nonzero.gene.t <- data.frame(row.names(trimmean.nonzero.gene.t));
        trimmean.nonzero.value <- cbind(row.trimmean.nonzero.gene.t, fpkm.gene, trimmean.nonzero.gene);
        colnames(trimmean.nonzero.value) <- c('patient', 'fpkm', 'gene');
        trimmean.nonzero.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = trimmean.nonzero.value,
            main = paste(e.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(d))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (trimmed mean.nonzero)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );      
    
        # Median plot
        f.order <- f[match(rownames(a), rownames(f)),];
        if (is.na(f.order[k,1]) | is.infinite(f.order[k,1])) {
            median.gene <- as.numeric(f.order[k, patient.part]);
            median.gene.t <- t(f.order[k, patient.part]);
            row.median.gene.t <- data.frame(row.names(median.gene.t));
            median.value <- cbind(row.median.gene.t, fpkm.gene, median.gene);
            colnames(median.value) <- c('patient', 'fpkm', 'gene');
            median.value.order <- median.value[order(median.value$fpkm, decreasing = TRUE),];
            median.value.order.number <- data.frame(cbind(c(1:length(patient.part)),
                                                          median.value.order));
            colnames(median.value.order.number) <- c('number', 'patient', 'fpkm', 'gene');
            median.value.order.number$gene <- 0;
            median.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ number,
                data = median.value.order.number,
                main = paste(f.order$Symbol[k],
                             'calculated using',
                             sub('.{7}.', '', substitute(f))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score (median)',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xaxis.lab = median.value.order.number$patient,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                border.lwd  = 0.2,
                yaxis.fontface = 'bold'
                );      
            }
        else {
            median.gene <- as.numeric(f.order[k, patient.part]);
            median.gene.t <- t(f.order[k, patient.part]);
            row.median.gene.t <- data.frame(row.names(median.gene.t));
            median.value <- cbind(row.median.gene.t, fpkm.gene, median.gene);
            colnames(median.value) <- c('patient', 'fpkm', 'gene');
            median.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ patient,
                data = median.value,
                main = paste(f.order$Symbol[k],
                             'calculated using',
                             sub('.{7}.', '', substitute(f))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                border.lwd  = 0.2,
                yaxis.fontface = 'bold',
                sample.order = 'decreasing'
                );      
            }
    
        # Median.nonzero plot
        g.order <- g[match(rownames(a), rownames(g)),];
        if (is.na(g.order[k,1]) | is.infinite(g.order[k,1])) {
            median.nonzero.gene <- as.numeric(g.order[k, patient.part]);
            median.nonzero.gene.t <- t(g.order[k, patient.part]);
            row.median.nonzero.gene.t <- data.frame(row.names(median.nonzero.gene.t));
            median.nonzero.value <- cbind(row.median.nonzero.gene.t, fpkm.gene, median.nonzero.gene);
            colnames(median.nonzero.value) <- c('patient', 'fpkm', 'gene');
            median.nonzero.value.order <- median.nonzero.value[order(median.nonzero.value$fpkm, decreasing = TRUE),];
            median.nonzero.value.order.number <- data.frame(cbind(c(1:length(patient.part)),
                                                                  median.nonzero.value.order));
            colnames(median.nonzero.value.order.number) <- c('number', 'patient', 'fpkm', 'gene');
            median.nonzero.value.order.number$gene <- 0;
            median.nonzero.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ number,
                data = median.nonzero.value.order.number,
                main = paste(g.order$Symbol[k],
                             'calculated using',
                             sub('.{7}.', '', substitute(g))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score (median)',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xaxis.lab = median.nonzero.value.order.number$patient,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                border.lwd  = 0.2,
                yaxis.fontface = 'bold'
                );      
            }
        else {
            median.nonzero.gene <- as.numeric(g.order[k, patient.part]);
            median.nonzero.gene.t <- t(g.order[k, patient.part]);
            row.median.nonzero.gene.t <- data.frame(row.names(median.nonzero.gene.t));
            median.nonzero.value <- cbind(row.median.nonzero.gene.t, fpkm.gene, median.nonzero.gene);
            colnames(median.nonzero.value) <- c('patient', 'fpkm', 'gene');
            median.nonzero.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ patient,
                data = median.nonzero.value,
                main = paste(g.order$Symbol[k],
                             'calculated using',
                             sub('.{7}.', '', substitute(g))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                border.lwd  = 0.2,
                yaxis.fontface = 'bold',
                sample.order = 'decreasing'
                );      
            }
             
        
        # Kmean plot
        h.order <- h[match(rownames(a), rownames(h)),];
        kmean.gene <- as.numeric(h.order[k, patient.part]);
        kmean.gene.t <- t(h.order[k, patient.part]);
        row.kmean.gene.t <- data.frame(row.names(kmean.gene.t));
        kmean.value <- cbind(row.kmean.gene.t, fpkm.gene, kmean.gene);
        colnames(kmean.value) <- c('patient', 'fpkm', 'gene');
        kmean.value.order <- kmean.value[order(kmean.value$fpkm, decreasing = TRUE),];
        kmean.value.order.number <- data.frame(cbind(c(1:length(patient.part)),
                                                     kmean.value.order));
        colnames(kmean.value.order.number) <- c('number', 'patient', 'fpkm', 'gene');
        kmean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ number,
            data = kmean.value.order.number,
            main = paste(h.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(h))),
            main.cex = 1.5,
            ylab.lab = 'z-score',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xaxis.lab = kmean.value.order.number$patient,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yat = seq(0,2,1),
            yaxis.fontface = 'bold'
            );
        
        # Kmean.nonzero plot
        i.order <- i[match(rownames(a), rownames(i)),];
        kmean.nonzero.gene <- as.numeric(i.order[k, patient.part]);
        kmean.nonzero.gene.t <- t(i.order[k, patient.part]);
        row.kmean.nonzero.gene.t <- data.frame(row.names(kmean.nonzero.gene.t));
        kmean.nonzero.value <- cbind(row.kmean.nonzero.gene.t, fpkm.gene, kmean.nonzero.gene);
        colnames(kmean.nonzero.value) <- c('patient', 'fpkm', 'gene');
        kmean.nonzero.value.order <- kmean.nonzero.value[order(kmean.nonzero.value$fpkm, decreasing = TRUE),];
        kmean.nonzero.value.order.number <- data.frame(cbind(c(1:length(patient.part)),
                                                             kmean.nonzero.value.order));
        colnames(kmean.nonzero.value.order.number) <- c('number', 'patient', 'fpkm', 'gene');
        kmean.nonzero.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ number,
            data = kmean.nonzero.value.order.number,
            main = paste(i.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(i))),
            main.cex = 1.5,
            ylab.lab = 'z-score',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.lab = kmean.nonzero.value.order.number$patient,
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            yat = seq(0,2,1),
            border.lwd  = 0.2,
            yaxis.fontface = 'bold'
            );
        
         
        ### Clinical data ###
        # Order the patients
        all.clinical.order <- j[match(kmean.value.order.number$patient, rownames(j)),];
        # Color
        isup.col <- BoutrosLab.plotting.general:::colour.gradient('lightyellow3', 5);
        psa.col.4 <- BoutrosLab.plotting.general:::colour.gradient('orange', 4);
        psa.col <- c('white', psa.col.4);
        age.col.4 <- BoutrosLab.plotting.general:::colour.gradient('lightpink', 4);
        grade.col.3 <- BoutrosLab.plotting.general:::colour.gradient('skyblue4', 3);
        all.col <- c(isup.col, psa.col, age.col.4, grade.col.3);
        #Make heatmap
        all.cov.heatmap <- BoutrosLab.plotting.general:::create.heatmap(
            x = all.clinical.order,
            clustering.method = 'none',
            colour.scheme = all.col, 
            total.colours = 18,
            row.colour = 'black',
            col.colour = 'black',
            grid.row = TRUE, 
            grid.col = TRUE, 
            yaxis.tck = 0, 
            xaxis.tck = 0,
            print.colour.key = FALSE,
            force.grid.row = TRUE,
            force.grid.col = TRUE
            );
        #Make legend
        legend.clinic <- BoutrosLab.plotting.general:::legend.grob(
            list(
                # create legend for ISUP
                legend = list(
                    colours = isup.col,
                    title = expression(underline('ISUP')), 
                    labels = c('1', '2', '3', '4', '5'),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5, 
                    border = 'black'
                    ),
                # create legend for PSA
                legend = list(
                    colours = psa.col,
                    title = expression(underline('PSA level')), 
                    labels = c('NA', expression('\u2264 '*'1'), '1 - 10', '10 - 100', expression('\u2265 '*'100')),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5, 
                    border = 'black'
                    ),
                # create legend for Age
                legend = list(
                    colours = age.col.4,
                    title = expression(underline('Age')), 
                    labels = c(expression('\u2264 '*'49'), '50 - 59', '60 - 69', expression('\u2265 '*'70')),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5, 
                    border = 'black'
                    ),
                # create legend for Grade
                legend = list(
                    colours = c('white', grade.col.3), 
                    title = expression(underline('Tumor Grade')), 
                    labels = c('NA', 'T2', 'T3', 'T4'),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5, 
                    border = 'black'
                    )
                ),
            title.just = 'left',
            title.fontface = 'plain')


        ###Final multiplot
        nonzero.fpkm <- round(sum(ifelse(fpkm.value$gene == 0, 0, 1))/length(patient.part)*100, 2);
        final.plot <- BoutrosLab.plotting.general:::create.multiplot(
            plot.objects = list(kmean.nonzero.bar, kmean.bar, median.nonzero.bar, median.bar, trimmean.nonzero.bar,
                                trimmean.bar, mean.nonzero.bar, mean.bar, fpkm.bar, all.cov.heatmap),
            main = paste(a$Symbol[k]),
            xlab.label = 'Patient',
            ylab.label = c('', '', 'FPKM', '', '', 'z-score (mean)', '', '', 'z-score (mean.nonzero)', '', '', 
                           'z-score (trimmean)', '', '', 'z-score (trimmean.nonzero)', '', '', 'z-score (median)', 
                           '', '', 'z-score (median.nonzero)', '', '',  'kmean', '', '',  'kmean.nonzero', ''),
            y.relation = 'free',
            panel.heights = c(1, 2, 2, 2, 2, 2, 2, 2, 2, 2),
            legend = list(right = list(fun = legend.clinic)),
            print.new.legend = TRUE,
            y.spacing = 0.5,
            key = list(
                title = expression(underline('Fraction of patient')),
                text = list(
                    lab = paste(as.character(nonzero.fpkm),'%'),
                    cex = 1,
                    col = 'black'
                    ),
                x = 0.9,
                y = 0.93,
                padding.text = 2,
                cex = 0.7,
                columns = 1
                ),
            main.cex = 1.3,
            xaxis.cex = 0.2,
            yaxis.cex = 0.7,
            yaxis.tck = 0.1,
            ylab.cex = 0.6,
            xlab.cex = 1,
            xaxis.lab = fpkm.value$patient,
            xaxis.rot = 90,
            xaxis.tck = 0.1
        )
        return(final.plot);
        }
    }

# Multi-waterfall plot
outlier.multiwaterfallplot(fpkm.data, gene.rank.order.6, mean.zscore, mean.nonzero.zscore,
                           trimmean.zscore, trimmean.nonzero.zscore, median.zscore,
                           median.nonzero.zscore, kmean.fraction, kmean.nonzero.fraction, all.clinical, num = 1);


```



## 12. Function for making bar plot of rank product on each chromosome position
```{r, fig.width=12, fig.height=11}
# Chromosomal position of rank product using bar plot
rank.chromosomal.position.bar <- function(x, chr.num = 24, data.col = 'steelblue4') {
    gene.list <- rownames(x);
    gene.list.sub <- substr(gene.list, 1, 15);
    ensembl <- biomaRt:::useEnsembl(biomart = 'ensembl', 
                                    dataset = 'hsapiens_gene_ensembl', 
                                    mirror = 'useast');
    ensembl <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl);
    gene.position <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
                                                    'start_position', 'end_position', 'band'),
                                     filters = 'ensembl_gene_id', 
                                     values = gene.list.sub, 
                                     mart = ensembl);

    #Get the gene, position matrix
    gene.biomart <- subset(x, gene.list.sub %in% gene.position$ensembl_gene_id);
    gene.position.order <- gene.position[order(as.numeric(gene.position$chromosome_name), 
                                               as.numeric(gene.position$start_position), 
                                               decreasing = FALSE),];
    gene.biomart.fpkm <- gene.biomart[match(gene.position.order$ensembl_gene_id, 
                                            substr(rownames(gene.biomart), 1, 15)),];
    chr.ord <- cbind(gene.biomart.fpkm, 
                     gene.position.order[, colnames(gene.position.order) %in% c('chromosome_name', 'start_position', 'end_position')]);
    chr.ord.na <- na.omit(chr.ord);
    chr.name <- c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
                  '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', 
                  '21', '22', 'MT', 'X', 'Y');
    chr.ord.na.numeric <- chr.ord.na;
    for (i in 1 : nrow(chr.ord.na.numeric)){
        if('MT' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '23';
            }
        if('X' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '24';
            }
        if('Y' == chr.ord.na.numeric$chromosome_name[i]) {
            chr.ord.na.numeric$chromosome_name[i] <- '25';
            }
        }

    for (i in 1 : chr.num) {
    chr <- na.omit(chr.ord.na.numeric[chr.ord.na.numeric$chromosome_name == i,]);
    chr.number <- cbind(chr, c(1:nrow(chr)));
    chr.heat <- BoutrosLab.plotting.general:::create.barplot(
            formula = -log10(rank.product.6) ~ c(1:nrow(chr)),
            data = chr.number,
            main = paste('Chr', chr.name[i], 
                         '- Rank Product of',
                         substr(substitute(x), 1, 4)),
            main.cex = 1.3,
            ylab.lab = '-log10(Rank product)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0,
            xaxis.lab = rep('', nrow(chr)),
            xlab.lab = 'gene',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.1,
            # yaxis.fontface = 'bold'
            col = data.col
            );
        return(chr.heat);
        }
    }

rank.chromosomal.position.bar(gene.rank.order.6, chr.num = 25);


```


## 13. File check - Check the correlation between FPKM and z-score
```{r}

# Check the correlation between FPKM and z-score
#  - if the correlation is low, error will occur.
#  x: FPKM data
#  y: z-score data
data.match.check <- function(x, y) {
    random.number <- sample(60308, 1000, replace = FALSE);
    cor.1000 <- NA;
    for ( i in 1:1000) {
        cor.1000[i] <- cor(t(x[random.number[i],]),
                           t(y[random.number[i],]),
                          method = 'spearman');
        }
    if (mean(na.omit(cor.1000)) > 0.9) {
        message('High correlation!');
        }
    else {
        stop('Low correlation!');
        }
    }


data.list <- list(mean.zscore,
                  mean.nonzero.zscore,
                  median.zscore,
                  median.nonzero.zscore,
                  trimmean.zscore,
                  trimmean.nonzero.zscore);

for (i in 1:length(data.list)) {
    data.match.check(fpkm.data[,patient.part], data.list[[i]][,patient.part]);
    }
        
        
```


## 14. Save session
```{r}

# ### Save session #####
# # Gene-wise session
# setwd('~/Documents/1.Project/1.CPCGENE_RNA-seq/Rawdata/TCGA_PC');
# save(fpkm.data,
#      patient.part,
#      molecular.data,
#      mean.zscore,
#      mean.nonzero.zscore,
#      median.zscore,
#      median.nonzero.zscore,
#      trimmean.zscore,
#      trimmean.nonzero.zscore,
#      kmean.fraction,
#      kmean.nonzero.fraction,
#      gene.zrange.fraction,
#      gene.zrange.fraction.direction,
#      gene.rank.order.5,
#      gene.rank.order.6,
#      file = '2020-12-15_TCGA_gene-wise_Outlier.rda');
#
# # Patient-wise session
# save(fpkm.data,
#      patient.part,
#      molecular.data,
#      pvalue.mean.sum,
#      pvalue.mean.nonzero.sum,
#      pvalue.trimmean.sum,
#      pvalue.trimmean.nonzero.sum,
#      pvalue.median.sum,
#      pvalue.median.nonzero.sum,
#      bon.mean.sum,
#      bon.mean.nonzero.sum,
#      bon.trimmean.sum,
#      bon.trimmean.nonzero.sum,
#      bon.median.sum,
#      bon.median.nonzero.sum,
#      adjust.p.mean.sum,
#      adjust.p.mean.nonzero.sum,
#      adjust.p.trimmean.sum,
#      adjust.p.trimmean.nonzero.sum,
#      adjust.p.median.sum,
#      adjust.p.median.nonzero.sum,
#      file = '2020-12-15_TCGA_patient-wise_Outlier.rda');

```




