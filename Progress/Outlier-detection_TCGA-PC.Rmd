---
title: "2021-12-18_Outlier_PRAD"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Make Outlier.function
```{r}

### Outlier.function.Rmd #######################################################
################################################################################
### 1. Function for making z-score matrix using each method (8 methods) 
# - Generate function for calculating z-score and Kmean cluster using each method
#   1. Use mean and SD
#   2. Use trimmed mean and trimmed SD
#   3. Use median and MAD 
#   4. Use K mean cluster

### 2. Function for outlier detection (calculating z-score range and kmean fraction) 
# - Generate function for calculating z-score range and kmean fraction
#   1. Calculate a range of z-score
#   2. Calculate a fraction of Kmean with smaller fraction
# - Generate gene-wise matrix

### 3. Function for checking whether the outliers are highly abundant or lowly abundant 
# - Generate the direction matrix

### 4. Function for making patient-wise outlier matrix 
# 1. P-value < 0.05
# 2. Bonferroni  correction < 0.05
# 3. Adjusted p-value < 0.05
# - Generate function for marking the patients over/under threshold
# - Generate function for calculating the number of outliers per patient

### 5. File check - match the name of patients 
# - Match the name of patients between FPKM file and z-score file

### 6. Function for making heatmap of z-score and FPKM 
# - Generate function for making heatmap in z-score and fpkm space

### 7. Function for making Waterfall plot 
# - Generate function for making waterfall plot with z-score and FPKM with showing the fraction of patients 

### 8. Function for checking out the technical problem 
# - Generate heatmap for the fraction of genes enriched on each chromosome
# - Check if there is any chromosome of which genes are enriched less than 20%

### 9. Function for making heatmap of each chromosome position 
# - Generate function for making heatmap for each chromosomal position

### 10. Function for ranking outliers 
# - Generate the ranking of outliers using rank product method
# - Generate heatmap for top 1000 ranked outliers in FPKM space
# - Generate heatmap for top 1000 ranked outliers in z-score
# - Count the number of outliers per patient
# - Generate heatmap for top 1000 ranked outliers ordered by the number of outliers per patient

### 11. Function for making multi-waterfall plot with clinical data 
# 1. ISUP
# 2. PSA
# 3. Age
# 4. Tumor grade
# - Merge clinical data in waterfall plot

### 12. Function for making bar plot of gene rank on each chromosome position 
# - Generate bar plot for each chromosome with rank of genes

### 13. File check - Check the correlation between FPKM and z-score 
# - Generate an error if the correlation is low

### 14. Save session 

################################################################################



### Input Variable #############################################################
# # TCGA PRAD RNA-seq data - TCGA-PRAD.htseq_fpkm.tsv
# # No gene symbol
# # - on the cluster
# setwd('~/mnt/avere/TCGA/RNA-seq/GBM');
# fpkm.data <- read.delim(
#     file = 'TCGA-GBM.htseq_fpkm.tsv',
#     row.names = 1
#     );
# 
# # Select tumor samples only
# # 01: primary tumor
# # 02: recurrent tumor
# # 11: solid normal tumor
# fpkm.tumor <- fpkm.data[, substr(colnames(fpkm.data), 14, 15) %in% c('01', '02')]
# 
# # Back convert to FPKM from log2(FPKM+1)
# fpkm.tumor.nonlog <- 2^fpkm.tumor -1
# 
# # Add Gene symbol
# library(EnsDb.Hsapiens.v79)
# gene.id <- substr(rownames(fpkm.data), 1, 15)
# gene.symbol <- ensembldb::select(EnsDb.Hsapiens.v79, keys = gene.id, keytype = "GENEID", columns = c("GENEID", "SYMBOL"))
# fpkm.tumor.matched <- subset(fpkm.tumor.nonlog, gene.id %in% gene.symbol$GENEID)
# fpkm.tumor.symbol <- cbind(fpkm.tumor.matched, gene.symbol$SYMBOL)
# colnames(fpkm.tumor.symbol) <- c(colnames(fpkm.tumor.nonlog), 'Symbol')
# 
# 
# #Give variable
# # input file : FPKM normalized RNA-seq data
# # input variable : fpkm.data - raw FPKM data
# #                  patient.part - exclude Symbol column for downstream analysis
# #                  molecular.data - data without Symbol column. Only have FPKM data
# patient.part <- 1:(ncol(fpkm.tumor.symbol)-1);
# molecular.data <- fpkm.tumor.symbol[, patient.part];

# # Get the genes with less than 1% of zero values
# zero.portion <- apply(fpkm.tumor.symbol[,patient.part], 1, function(x) {length(x[0 == x]) / length(patient.part)});
# fpkm.tumor.symbol.filter <- fpkm.tumor.symbol[rownames(fpkm.tumor.symbol) %in% names(zero.portion[0.01 > zero.portion]),];
# molecular.data.filter <- fpkm.tumor.symbol.filter[, patient.part];


### Load session #####
setwd('~/Documents/1.Project/TCGA/TCGA-PRAD');
load(file = '2021-04-21_outlier_PRAD.rda');
# Clinical data
setwd('~/Documents/1.Project/1.CPCGENE_RNA-seq/Rawdata/Clinical_data/');
clinical.data <- read.delim(
    file = 'prad_tcga_clinical_data.tsv'
    );

```


## 1. Function for making z-score matrix using each method (8 methods)#####
```{r}

# ### Outlier.Function ###########################################################
# ### MEAN and SD #####
# # Function parameter
# # Default : methods = 'mean', trim = 0
# # 1. MEAN and SD : methods = 'mean', trim = 0
# # 2. TRIMMED MEAN and TRIMMED SD : methods = 'mean', trim = 5
# # 3. MEDIAN and MAD : methods = 'median'
# # 4. KMEAN : methods = 'kmean'
# 
# # Function - outlier.mean()
# quantify.outliers <- function(x, method = 'mean', trim = 0) {
#     x.num <- as.numeric(x);
#     if (any(is.na(x.num))) {
#         x <- 0;
#         }
#     else {
#         if ('median' == method) {
#             x.median <- median(x.num);
#             x.mad <- mad(x.num);
#             (x - x.median) / x.mad;
#             }
#         else if ('kmean' == method) {
#             if (length(unique(x.num)) == 1) {
#                 kmean.matrix <- rep(NA, length(x.num));
#                 names(kmean.matrix) <- names(x);
#                 }
#             else {
#                 kmean <- kmeans(x.num, 2, nstart = 1000);
#                 cluster <- kmean$cluster;
#                 kmean.matrix <- cluster;
#                 names(kmean.matrix) <- names(x);
#                 }
#             kmean.matrix;
#             }
#         else {
#             gene.order <- x.num[order(x.num, decreasing = TRUE)];
#             top.patient <- round(length(x.num) * (trim / 100), digit = 0);
#             low.patient <- round(length(x.num) * (1 - (trim / 100)), digit = 0);
#             x.mean <- mean(gene.order, trim = (trim / 100));
#             x.sd <- sd(gene.order[(top.patient+1):(low.patient)]);
#             (x - x.mean) / x.sd;
#             }
#         }
#     }
# 
# 
# # 1. MEAN and SD : method = 'mean', trim = 0
# data.mean <- apply(molecular.data.filter, 1, quantify.outliers);
# data.mean.t <- t(data.mean);
# data.mean.t <- data.frame(data.mean.t);
# 
# # 2. TRIMMED MEAN and TRIMMED SD : method = 'mean', trim = 5
# data.trimmean <- apply(molecular.data.filter, 1, quantify.outliers, trim = 5);
# data.trimmean.t <- t(data.trimmean);
# data.trimmean.t <- data.frame(data.trimmean.t);
# 
# # 3. MEDIAN and MAD : method = 'median'
# data.median <- apply(molecular.data.filter, 1, quantify.outliers, method = 'median');
# data.median.t <- t(data.median);
# data.median.t <- data.frame(data.median.t);
# 
# # 4. KMEAN : method = 'kmean'
# data.kmean <- apply(molecular.data.filter, 1, quantify.outliers, method = 'kmean');
# data.kmean.t <- t(data.kmean);
# data.kmean.t <- data.frame(data.kmean.t);



```



## 2. Function for outlier detection (calculating z-score range and kmean fraction) 
```{r}
# ### Calculate the range of z-score #####
# # Function 
# outlier.detection.zrange <- function(x) {
#     zrange <- max(x) - min(x);
#     zrange.matrix <- c(x, zrange);
#     names(zrange.matrix) <- c(names(x), 'zrange');
#     zrange.matrix;
#     }
# 
# 
# # 1. MEAN and SD
# data.zrange.mean <- apply(data.mean.t, 1, outlier.detection.zrange);
# data.zrange.mean.t <- data.frame(t(data.zrange.mean));
# mean.zscore <- cbind(data.zrange.mean.t, fpkm.tumor.symbol.filter$Symbol);
# colnames(mean.zscore) <- c(colnames(data.zrange.mean.t), 'Symbol');
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# data.zrange.trimmean <- apply(data.trimmean.t, 1, outlier.detection.zrange);
# data.zrange.trimmean.t <- data.frame(t(data.zrange.trimmean));
# trimmean.zscore <- cbind(data.zrange.trimmean.t, fpkm.tumor.symbol.filter$Symbol);
# colnames(trimmean.zscore) <- c(colnames(data.zrange.trimmean.t), 'Symbol');
# 
# # 3. MEDIAN and MAD
# data.zrange.median <- apply(data.median.t, 1, outlier.detection.zrange);
# data.zrange.median.t <- data.frame(t(data.zrange.median));
# median.zscore <- cbind(data.zrange.median.t, fpkm.tumor.symbol.filter$Symbol);
# colnames(median.zscore) <- c(colnames(data.zrange.median.t), 'Symbol');
# 
# 
# 
# 
# ### Calculate the kmean fraction #####
# # Function 
# outlier.detection.kmean <- function(x) {
#     if (1== length(unique(as.numeric(x)))) {
#         fraction <- NA;
#         } 
#     else {
#         cluster.one <- length(x[x == 1]);
#         cluster.two <- length(x[x == 2]);
#         cluster.sum <- cluster.one + cluster.two;
#         smaller.value <- min(cluster.one, cluster.two);
#         fraction <- round(smaller.value/cluster.sum, digit = 4);
#         }
#     fraction.matrix <- c(x, fraction);
#     names(fraction.matrix) <- c(names(x), 'fraction');
#     fraction.matrix;
#     }
# 
# # 4. KMEAN fraction
# data.fraction.kmean <- apply(data.kmean.t, 1, outlier.detection.kmean);
# data.fraction.kmean.t <- data.frame(t(data.fraction.kmean));
# kmean.fraction <- cbind(data.fraction.kmean.t, fpkm.tumor.symbol.filter$Symbol);
# colnames(kmean.fraction) <- c(colnames(data.fraction.kmean.t), 'Symbol');
# 
# 
# 
# 
# ### Final gene-wise matrix #####
# gene.zrange.fraction <- cbind(mean.zscore$zrange,
#                      median.zscore$zrange,
#                      trimmean.zscore$zrange,
#                      kmean.fraction$fraction,
#                      data.frame(fpkm.tumor.symbol.filter$Symbol));
# rownames(gene.zrange.fraction) <- rownames(molecular.data.filter);
# colnames(gene.zrange.fraction) <- c('zrange.mean', 'zrange.median', 'zrange.trimmean', 'fraction.kmean', 'Symbol');

```



## 3. Function for checking whether the outliers are highly abundant or lowly abundant
```{r}
# ### Check whether the outliers are highly abundant or lowly abundant #####
# # Function
# # Show the max or min value
# zrange.direction <- function (x) {
#     num.x <- as.numeric(x); #names(x) will need for final output
#     if (is.na(max(x)) | is.infinite(max(num.x))) {
#         max.min <- NA;
#         }
#     else {
#         if (abs(max(num.x)) > abs(min(num.x))) {
#             max.min <- max(num.x);
#             }
#         else if (abs(max(num.x)) < abs(min(num.x))) {
#             max.min <- min(num.x);
#             }
#         else {
#             max.min <- NA;
#             }
#         }
#     max.min;
#     }
# 
# # Check with Mean/SD z-score
# # - if direction < 0, the gene is lowly abundant
# # - if direction > 0, the gene is highly abundant
# #  MEAN and SD
# direction.mean <- apply(mean.zscore[,patient.part], 1, zrange.direction);
# mean.zscore.direction <- cbind(mean.zscore, direction.mean);
# 
# 
# ### Check whether the outliers are highly abundant or lowly abundant #####
# # Function
# # Highly abundant gene : 1
# # Lowly abundant gene : -1
# # NA : NA
# outlier.direction <- function (x) {
#     if (is.na(x)) {
#         return(NA);
#         }
#     else if (x > 0) {
#         return(1);
#         }
#     else if (x < 0) {
#         return(-1);
#         }
#     else {
#         return(0);
#         }
#     }
# 
# direction <- apply(data.frame(direction.mean), 1, outlier.direction);
# gene.zrange.fraction.direction <- cbind(gene.zrange.fraction, direction);
head(gene.zrange.fraction.direction);


```


## 4. Function for making patient-wise outlier matrix
```{r, fig.width=11, fig.height=7}

# ### Make patient-wise outlier matrix  #####
# # Function 
# # Mark the patients over/under threshold
# outlier.sample <- function(x, zscore) { 
#     outlier.count <- NA;
#     x.num <- as.numeric(x); #names(x) will need for final output
#     for (i in 1: length(x)) {
#         if (is.na(x.num[i]) | is.infinite(x.num[i])) {
#             outlier.count[i] <- 0;
#             } 
#         else if (x.num[i] > zscore) {
#             outlier.count[i] <- 1;
#             } 
#         else if (x.num[i] < -zscore) {
#             outlier.count[i] <- -1;
#             } 
#         else {
#             outlier.count[i] <- 0;
#             }
#         }
#     names(outlier.count) <- names(x);
#     outlier.count;
#     }
# 
# 
# ### Make patient-wise outlier matrix  #####
# # Function 
# # Calculate the sum of outliers per patient
# outlier.sample.sum <- function(x) {
#     x.num <- as.numeric(x); #names(x) will need for final output 
#     high.number <- length(x.num[x.num == 1]) ;
#     low.number <- length(x.num[x.num == -1]) ;
#     number.outlier <- high.number + low.number;
#     sample.outlier <- c(number.outlier, high.number, low.number, x);
#     names(sample.outlier) <- c('sum', 'high', 'low', names(x));
#     sample.outlier;
#     }
# 
# 
# 
# ### Use threshold p-value < 0.05 (z-score > 1.96 / z-score < -1.96) ###
# ## Mark the patients over/under threshold
# # p-value
# p.value <- qnorm(0.05/2, lower.tail=FALSE);
# p.value;
# 
# # 1. MEAN and SD
# pvalue.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
# pvalue.mean.t <- data.frame(t(pvalue.mean));
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# pvalue.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
# pvalue.trimmean.t <- data.frame(t(pvalue.trimmean));
# 
# # 3. MEDIAN and MAD
# pvalue.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = p.value);
# pvalue.median.t <- data.frame(t(pvalue.median));
# 
# 
# ## Calculate the sum of outliers per patient
# # 1. MEAN and SD
# pvalue.mean.sum <- apply(pvalue.mean.t, 2, outlier.sample.sum);
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# pvalue.trimmean.sum <- apply(pvalue.trimmean.t, 2, outlier.sample.sum);
# 
# # 3. MEDIAN and MAD
# pvalue.median.sum <- apply(pvalue.median.t, 2, outlier.sample.sum);
# pvalue.median.sum[1:3,];
# hist(pvalue.median.sum[1,],
#      main = 'number of outliers (median): p-value < 0.05',
#      xlab = 'number of outliers');
# 
# 
# 
# 
# ### Use threshold Bonferroni < 0.05  ###
# ## Mark the patients over/under threshold
# # Bonferroni correction
# bonferroni.threshold <- 0.05 / (length(patient.part) * nrow(molecular.data.filter));
# bonferroni <- qnorm(bonferroni.threshold/2, lower.tail=FALSE);
# bonferroni;
# 
# # 1. MEAN and SD
# bon.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
# bon.mean.t <- data.frame(t(bon.mean));
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# bon.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
# bon.trimmean.t <- data.frame(t(bon.trimmean));
# 
# # 3. MEDIAN and MAD
# bon.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = bonferroni);
# bon.median.t <- data.frame(t(bon.median));
# 
# 
# ## Calculate the sum of outliers per patient
# # 1. MEAN and SD
# bon.mean.sum <- apply(bon.mean.t, 2, outlier.sample.sum);
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# bon.trimmean.sum <- apply(bon.trimmean.t, 2, outlier.sample.sum);
# 
# # 3. MEDIAN and MAD
# bon.median.sum <- apply(bon.median.t, 2, outlier.sample.sum);
# bon.median.sum[1:3,]
# hist(bon.median.sum[1,],
#      main = 'number of outliers (median): p-value < 0.05/(number.gene*number.patient)',
#      xlab = 'number of outliers');
# 
# 
# 
# 
# 
# ### Use threshold p-threshold-adjusted = p-threshold / (number.patient x number.gene x number.methods) ###
# ## Mark the patients over/under threshold
# # number of methods
# methods.num <- c('mean', 'trimmean', 'median', 'kmean');
# adjust.p.threshold <- 0.05 / (length(patient.part) * nrow(molecular.data.filter) * length(methods.num));
# adjust.p <- qnorm(adjust.p.threshold/2, lower.tail=FALSE);
# adjust.p;
# 
# # 1. MEAN and SD
# adjust.p.mean <- apply(mean.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
# adjust.p.mean.t <- data.frame(t(adjust.p.mean));
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# adjust.p.trimmean <- apply(trimmean.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
# adjust.p.trimmean.t <- data.frame(t(adjust.p.trimmean));
# 
# # 3. MEDIAN and MAD
# adjust.p.median <- apply(median.zscore[,patient.part], 1, outlier.sample, zscore = adjust.p);
# adjust.p.median.t <- data.frame(t(adjust.p.median));
# 
# 
# ## Calculate the sum of outliers per patient
# # 1. MEAN and SD
# adjust.p.mean.sum <- apply(adjust.p.mean.t, 2, outlier.sample.sum);
# 
# # 2. TRIMMED MEAN and TRIMMED SD
# adjust.p.trimmean.sum <- apply(adjust.p.trimmean.t, 2, outlier.sample.sum);
# 
# # 3. MEDIAN and MAD
# adjust.p.median.sum <- apply(adjust.p.median.t, 2, outlier.sample.sum);
# adjust.p.median.sum[1:3,];
# hist(adjust.p.median.sum[1,],
#      main = 'number of outliers (median): p-value < 0.05/(number.gene*number.patient)',
#      xlab = 'number of outliers');



```


## 5. File check - match the name of patients
```{r}
# 
# # Match the name of patients
# #  - if patient set is not same, error will occur.
# #  x: FPKM data
# #  y: z-score data
# patient.match.check <- function(x, y) {
#     tryCatch(
#         expr = {
#             colnames(x) == colnames(y);
#             message('Same patient set!') ;
#             },
#         warning = function(e){
#             stop('Patient does not match. Check the data!');
#             }
#         )
#     }
# 
# 
# 
# data.list <- list(mean.zscore,
#                   median.zscore,
#                   trimmean.zscore,
#                   kmean.fraction,
#                   # pvalue.mean.sum,
#                   # pvalue.trimmean.sum,
#                   # pvalue.median.sum,
#                   # bon.mean.sum,
#                   # bon.trimmean.sum,
#                   # bon.median.sum,
#                   # adjust.p.mean.sum,
#                   # adjust.p.trimmean.sum,
#                   # adjust.p.median.sum
#                   );
# 
# for (i in 1:length(data.list)) {
#     patient.match.check(fpkm.tumor.symbol.filter[,patient.part], data.list[[i]][,patient.part]);
#     }


```


## 6. Function for making heatmap of z-score and FPKM
```{r, fig.width=11, fig.height=10}
# ### Make heatmap for Top 200 genes
# # input variable : the file with z-score and the range of z-score from each methods
# 
# # Make a heatmap in z-score space
# outlier.heatmap.zscore <- function(x) {
#     order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
#     order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
#     order.num.symbol <- cbind(order.num, order$Symbol);
#     colnames(order.num.symbol) <- colnames(order);
#     rownames(order.num.symbol) <- rownames(order);
#     order.na <- na.omit(order.num.symbol);
#     order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
#     zscore.heat <- BoutrosLab.plotting.general:::create.heatmap(
#         x = order.na.inf[1:200, 1:(length(x)-2)],
#         clustering.method = 'ward.D2',
#         cluster.dimensions = 'both',
#         yaxis.lab = NA,
#         yaxis.cex = 0.3,
#         xaxis.lab = order.na.inf$Symbol,
#         xaxis.cex = 0.3,
#         main = paste('The z-score of top 200 genes calculated using',
#                      sub('.{7}$', '', substitute(x))),
#         main.cex = 1.5,
#         grid.col = FALSE,
#         print.colour.key = TRUE,
#         yaxis.tck = 0.1,
#         xaxis.tck = 0.1,
#         colour.scheme = c('red4', 'white', 'dodgerblue4'),
#         colour.centering.value = 0,
#         at = seq(-5,5,0.001),
#         colourkey.cex = 1,
#         resolution = 300,
#         rows.distance.method = 'euclidean',
#         cols.distance.method = 'euclidean'
#         );
#     zscore.heat;
#     }
# 
# outlier.heatmap.zscore(median.zscore);
# 
# 
# #Make a heatmap in FPKM space
# # x : z-score matrix
# # y : raw FPKM matrix
# outlier.heatmap.fpkm <- function(x, y) {
#     order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
#     order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
#     order.num.symbol <- cbind(order.num, order$Symbol);
#     colnames(order.num.symbol) <- colnames(order);
#     rownames(order.num.symbol) <- rownames(order);
#     order.na <- na.omit(order.num.symbol);
#     order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
#     fpkm <- y[rownames(y) %in% rownames(order.na.inf)[1:200],];
#     fpkm.log <- log10((fpkm[ , 1:(length(fpkm)-1)])+1)
#     fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
#         x = fpkm.log,
#         clustering.method = 'ward.D2',
#         cluster.dimensions = 'both',
#         yaxis.lab = NA,
#         yaxis.cex = 0.3,
#         xaxis.lab = fpkm$Symbol,
#         xaxis.cex = 0.3,
#         main = paste('FPKM value of top 200 genes calculated using',
#                      sub('.{7}$', '', substitute(x)),
#                      'in log10 space'),
#         main.cex = 1.3,
#         grid.col = FALSE,
#         print.colour.key = TRUE,
#         yaxis.tck = 0.1,
#         xaxis.tck = 0.1,
#         colour.scheme = c('white', 'dodgerblue4'),
#         at = seq(0,1,0.001),
#         colourkey.cex = 1,
#         resolution = 300,
#         rows.distance.method = 'euclidean',
#         cols.distance.method = 'euclidean'
#         );
#     fpkm.heat;
#     }
# 
# outlier.heatmap.fpkm(median.zscore, fpkm.tumor.symbol.filter);

```



## 7. Function for making Waterfall plot 
```{r, fig.width=10, fig.height=6}

#Make multiplot for z-score and FPKM value
# x : z-score matrix
# y : raw FPKM matrix
# z : number of plot

outlier.waterfallplot <- function(x, y, plot.num = 1, kmean = FALSE, threshold = FALSE) {
    if (kmean) {
        order <- x[order(x[,(length(x)-1)], decreasing = FALSE),];
        z.color = 'black';
        }
    else {
        order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
        }
    order.na <- na.omit(order);
    order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
    for (i in 1:plot.num ) {
        if (kmean) {
            patient.part <- 1: (length(order.na.inf)-2);
            a <- t(order.na.inf[i,patient.part]);
            z.gene <- as.numeric(order.na.inf[i,patient.part]);
            row.a <- data.frame(row.names(a));
            gene.a <- cbind(row.a, z.gene);
            colnames(gene.a) <- c('patient', 'gene');
            sum.one <- sum(gene.a$gene == 1)
            sum.two <- sum(gene.a$gene == 2)
            if (sum.one < sum.two) {
                fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                    formula = gene ~ patient,
                    data = gene.a,
                    main = paste(order.na.inf$Symbol[i],
                                 'calculated using',
                                 sub('.{7}$', '', substitute(x))),
                    main.cex = 1.5,
                    ylab.lab = 'Z-Score',
                    yaxis.cex = 1,
                    ylab.cex = 1,
                    xaxis.tck = 0.2,
                    xlab.lab = 'Patient',
                    xaxis.rot = 90,
                    xaxis.cex = 0.3,
                    xlab.cex = 1,
                    yaxis.tck = 1,
                    yaxis.fontface = 'bold',
                    sample.order = 'increasing'
                    );
                }
            else {
                fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                    formula = gene ~ patient,
                    data = gene.a,
                    main = paste(order.na.inf$Symbol[i],
                                 'calculated using',
                                 sub('.{7}$', '', substitute(x))),
                    main.cex = 1.5,
                    ylab.lab = 'Z-Score',
                    yaxis.cex = 1,
                    ylab.cex = 1,
                    xaxis.tck = 0.2,
                    xlab.lab = 'Patient',
                    xaxis.rot = 90,
                    xaxis.cex = 0.3,
                    xlab.cex = 1,
                    yaxis.tck = 1,
                    yaxis.fontface = 'bold',
                    sample.order = 'decreasing'
                    );
                }
            }
        else {
            patient.part <- 1: (length(order.na.inf)-2);
            a <- t(order.na.inf[i,patient.part]);
            z.gene <- as.numeric(order.na.inf[i,patient.part]);
            row.a <- data.frame(row.names(a));
            gene.a <- cbind(row.a, z.gene);
            colnames(gene.a) <- c('patient', 'gene');
            z.gene.order <- z.gene[order(z.gene, decreasing =TRUE)];
            if (threshold) {
                z.color <- NA
                for (k in 1: (length(order.na.inf)-2)) {
                    if (z.gene.order[k] > threshold) {
                        z.color[k] <- 'red';
                        }
                    else {
                      z.color[k] <- 'black';
                        }
                    }
                }
            else {
              z.color <- 'black';
                }
            fraction.bar <- BoutrosLab.plotting.general:::create.barplot(
                formula = gene ~ patient,
                data = gene.a,
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{7}$', '', substitute(x))),
                main.cex = 1.5,
                ylab.lab = 'Z-Score',
                yaxis.cex = 1,
                ylab.cex = 1,
                xaxis.tck = 0.2,
                xlab.lab = 'Patient',
                xaxis.rot = 90,
                xaxis.cex = 0.3,
                xlab.cex = 1,
                yaxis.tck = 1,
                yaxis.fontface = 'bold',
                col = z.color,
                sample.order = 'decreasing'
                );
            }

        fpkm.gene <- as.numeric(y[rownames(order.na.inf)[i],patient.part]);
        fpkm.b <- cbind(row.a, fpkm.gene);
        colnames(fpkm.b) <- c('patient', 'gene');
        nonzero.fpkm <- round(sum(ifelse(fpkm.b$gene == 0, 0, 1))/length(patient.part)*100, 2);
        fpkm.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = fpkm.b,
            main = order.na.inf$Symbol[i],
            main.cex = 1.5,
            ylab.lab = 'FPKM',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            yaxis.fontface = 'bold',
            col = z.color,
            sample.order = 'decreasing'
            );
        if (kmean) {
            final.plot <- BoutrosLab.plotting.general:::create.multiplot(
                plot.objects = list(fpkm.bar, fraction.bar),
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{7}$', '', substitute(x)),
                             'z-score threshold =',
                             round(threshold, digits = 2)),
                xlab.label = 'Patient',
                ylab.label = c('Z-score', 'FPKM'),
                y.relation = 'free',
                main.cex = 1.3,
                xaxis.cex = 0.3,
                yaxis.cex = 0.7,
                ylab.cex = 1,
                xlab.cex = 1,
                xaxis.rot = 90,
                xaxis.tck = 0.2,
                key = list(
                    title = expression(underline('Fraction of patient')),
                    text = list(
                        lab = paste(as.character(nonzero.fpkm),'%'),
                        cex = 1.1,
                        col = 'black'
                        ),
                    x = 0.75,
                    y = 0.4,
                    padding.text = 3,
                    columns = 1
                    ),
                resolution = 50
                );
            }
        else {
            final.plot <- BoutrosLab.plotting.general:::create.multiplot(
                plot.objects = list(fpkm.bar, fraction.bar),
                main = paste(order.na.inf$Symbol[i],
                             'calculated using',
                             sub('.{7}$', '', substitute(x)),
                             'z-score threshold =',
                             round(threshold, digits = 2)),
                xlab.label = 'Patient',
                ylab.label = c('Z-score', 'FPKM'),
                y.relation = 'free',
                main.cex = 1.3,
                xaxis.cex = 0.3,
                yaxis.cex = 0.7,
                ylab.cex = 1,
                xlab.cex = 1,
                xaxis.rot = 90,
                xaxis.tck = 0.2,
                key = list(
                    title = expression(underline('Fraction of patient')),
                    text = list(
                        lab = paste(as.character(nonzero.fpkm),'%'),
                        cex = 1.1,
                        col = 'black'
                        ),
                    x = 0.75,
                    y = 0.4,
                    padding.text = 3,
                    columns = 1
                    ),
                resolution = 50
                );
            }
        print(final.plot);
        }
    }


# ### Use threshold p-value < 0.05 (z-score > 1.96 / z-score < -1.96) ###
# ## Mark the patients over/under threshold
# # p-value 
# p.value <- qnorm(0.05/2, lower.tail=FALSE);
# outlier.waterfallplot(median.zscore, fpkm.tumor.symbol.filter, plot.num = 1, threshold = p.value);
# 
# 
# ### Use threshold Bonferroni < 0.05  ###
# ## Mark the patients over/under threshold
# # Bonferroni correction 
# bon <- 0.05/length(patient.part);
# bon.zscore <- qnorm(bon/2, lower.tail=FALSE);
# outlier.waterfallplot(median.zscore, fpkm.tumor.symbol.filter, plot.num = 1, threshold = bon.zscore);
# 
# 
### Use threshold p-threshold-adjusted = p-threshold / (number.patient x number.methods) ###
## Mark the patients over/under threshold
# number of methods
# methods.num <- c('mean', 'trimmean', 'median', 'kmean');
# adjust.p.threshold <- 0.05/(length(patient.part)*length(methods.num));
# adjust.p.zscore <- qnorm(adjust.p.threshold/2, lower.tail=FALSE);
# outlier.waterfallplot(median.zscore, fpkm.tumor.symbol.filter, plot.num = 1, threshold = adjust.p.zscore);
# 
# 
# ### K-mean matrix in waterfall plot
# outlier.waterfallplot(kmean.fraction, fpkm.tumor.symbol.filter, plot.num = 1, kmean = TRUE);


```

## 8. Function for checking out the technical problem
```{r, fig.width=11, fig.height=10}

# ### Make heatmap for the fraction of genes enriched on each chromosome
# #   Show the list of patients with chromosome and the fraction which show the low enrichment (< 20%)
# # input variable 
# #   molecular.data.filter : check the number of the genes (FPKM > 0)
# 
# 
# outlier.technical.problem <- function(x) {
#     gene.list.all <- rownames(x);
#     gene.list.all.sub <- substr(gene.list.all, 1, 15);
#     ensembl.all <- biomaRt:::useEnsembl(biomart = 'ensembl', 
#                                         dataset = 'hsapiens_gene_ensembl', 
#                                         mirror = 'uswest');
#     ensembl.all <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl.all);
#     gene.position.all <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
#                                                         'start_position', 'end_position', 'band'),
#                                          filters = 'ensembl_gene_id', 
#                                          values = gene.list.all.sub, 
#                                          mart = ensembl.all);
#     gene.all <- subset(fpkm.tumor.symbol.filter, gene.list.all.sub %in% gene.position.all$ensembl_gene_id);
#     gene.position.order.all <- gene.position.all[order(as.numeric(gene.position.all$chromosome_name),
#                                                        as.numeric(gene.position.all$start_position), 
#                                                        decreasing = FALSE),];
#     gene.biomart.fpkm.all <- gene.all[match(gene.position.order.all$ensembl_gene_id, 
#                                             substr(rownames(gene.all), 1, 15)),];
#     chr.ord.all <- cbind(gene.biomart.fpkm.all, 
#                          gene.position.order.all[,3:5]);
#     
#     chr.matrix <- data.frame();
#     for (i in 1 : 22) {
#         chr <- chr.ord.all[chr.ord.all$chromosome_name == i, ];
#         chr.num <- nrow(chr);
#         for (k in 1 : length(patient.part)) {
#             gene.num <- sum(chr[, k] != 0);
#             chr.matrix[i,k] <- gene.num / chr.num;
#             }
#         }
#     colnames(chr.matrix) <- colnames(x);
#     
#     chr.fraction.heat <- BoutrosLab.plotting.general:::create.heatmap(
#        x = chr.matrix,
#        clustering.method = 'none',
#        cluster.dimensions = 'none',
#        yaxis.lab = NA,
#        yaxis.cex = 0.3,
#        xaxis.lab = paste('chr', rownames(chr.matrix)),
#        xaxis.cex = 1,
#        main = 'The fraction of genes enriched on each chromosome',
#        main.cex = 1.5,
#        grid.col = FALSE,
#        print.colour.key = TRUE,
#        yaxis.tck = 0.1,
#        xaxis.tck = 0.1,
#        colour.scheme = c('white','red4'),
#        colour.centering.value = 0.5,
#        at = seq(0,1,0.001),
#        colourkey.cex = 1,
#        resolution = 300,
#        );
#     
#     abnormal.matrix <- data.frame();
#     for (i in 1 : 22) {
#         for (k in 1 : length(patient.part)) {
#             if (chr.matrix[i, k] < 0.2) {
#                 abnormal.chr <- cbind(colnames(chr.matrix)[k], paste('chr', rownames(chr.matrix)[i]), chr.matrix[i, k]);
#                 abnormal.matrix <- rbind(abnormal.matrix, abnormal.chr);
#                 }
#             }
#         }
#     
#     if (length(abnormal.matrix) > 0) {
#     colnames(abnormal.matrix) <- c('patient', 'chr', 'fraction');
#     abnormal.matrix$fraction <- round(as.numeric(abnormal.matrix$fraction), digits = 3);
#         }
#     
#     list(abnormal.pattern = abnormal.matrix, fraction.heatmap = chr.fraction.heat);
#     }
# 
# outlier.technical.problem(molecular.data.filter);


```

## 9. Function for making heatmap of each chromosome position
```{r, fig.width=11, fig.height=10}

# ### Make heatmap for chromosomal position
# # input variable 
# #   x: the file with z-score and the range of z-score from each methods
# #   chr.num: 24 for women (No Y chromosome)
# #            25 for men 
# 
# 
# outlier.position <- function(x, chr.num = 24) {
#     order <- x[order(x[,(length(x)-1)], decreasing = TRUE),];
#     order.num <- data.frame(sapply(order[,1:(length(x)-1)], as.numeric));
#     order.num.symbol <- cbind(order.num, order$Symbol);
#     colnames(order.num.symbol) <- colnames(order);
#     rownames(order.num.symbol) <- rownames(order);
#     order.na <- na.omit(order.num.symbol);
#     order.na.inf <- order.na[is.finite(order.na[,(length(x)-1)]),];
#     patient.part <- 1: (length(order.na.inf)-2);
#     gene.list.all <- rownames(order.na.inf);
#     gene.list.all.sub <- substr(gene.list.all, 1, 15);
#     ensembl.all <- biomaRt:::useEnsembl(biomart = 'ensembl', 
#                                         dataset = 'hsapiens_gene_ensembl', 
#                                         mirror = 'uswest');
#     ensembl.all <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl.all);
#     gene.position.all <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
#                                                         'start_position', 'end_position', 'band'),
#                                          filters = 'ensembl_gene_id', 
#                                          values = gene.list.all.sub, 
#                                          mart = ensembl.all);
#     gene.all <- subset(order.na.inf, gene.list.all.sub %in% gene.position.all$ensembl_gene_id);
#     gene.position.order.all <- gene.position.all[order(as.numeric(gene.position.all$chromosome_name),
#                                                        as.numeric(gene.position.all$start_position), 
#                                                        decreasing = FALSE),];
#     gene.biomart.fpkm.all <- gene.all[match(gene.position.order.all$ensembl_gene_id, 
#                                             substr(rownames(gene.all), 1, 15)),];
#     chr.ord.all <- cbind(gene.biomart.fpkm.all, 
#                          gene.position.order.all[,colnames(gene.position.order.all) %in% c('chromosome_name', 'start_position', 'end_position')]);
#     chr.ord.na <- na.omit(chr.ord.all);
#     chr.name <- c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10', 
#                   '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', 
#                   '21', '22', 'MT', 'X', 'Y');
#     chr.ord.na.numeric <- chr.ord.na;
#     for (i in 1 : nrow(chr.ord.na.numeric)){
#         if('MT' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '23';
#             }
#         if('X' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '24';
#             }
#         if('Y' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '25';
#             }
#         }
#     for (i in 1 : chr.num) {
#         heat <- BoutrosLab.plotting.general:::create.heatmap(
#             x = chr.ord.na.numeric[chr.ord.na.numeric$chromosome_name == i, patient.part],
#             clustering.method = 'ward.D2',
#             cluster.dimensions = 'row',
#             main = paste('Chr', chr.name[i], 
#                          '- the z-score of all genes calculated using',
#                          sub('.{7}$', '', substitute(x))),
#             main.cex = 1.5,
#             colourkey.cex = 1,
#             scale.data = FALSE,
#             colour.scheme = c('red4', 'white', 'dodgerblue4'),
#             colour.centering.value = 0,
#             at = seq(-5,5,0.001),
#             yaxis.lab = NA,
#             yaxis.cex = 0.3,
#             rows.distance.method = 'euclidean',
#             resolution = 500
#             );
#         print(heat);
#         }
#     }
# 
# outlier.position(median.zscore, chr.num = 1);


```

 
## 10. Function for ranking outliers 
```{r, fig.width=12, fig.height=11}
# ### Rank each methods #####
# # Function
# outlier.rank <- function(x) {
#     methods <- c('zrange.mean', 'zrange.median', 'zrange.trimmean', 'fraction.kmean');
#     rank.matrix <- NULL;
#     # Give rank for each methods based on z-score range/fraction of kmean
#     for (i in 1:3) {
#         methods.column <- methods[i];
#         rank.methods <- rank(-x[,methods.column], ties.method = 'max', na.last = 'keep');
#         rank.matrix <- cbind(rank.matrix, rank.methods);
#         }
#     for (i in 4) {
#         methods.column <- methods[i];
#         rank.methods <- rank(x[,methods.column], ties.method = 'max', na.last = 'keep');
#         rank.matrix <- cbind(rank.matrix, rank.methods);
#         }
#     rank.matrix <- cbind(rank.matrix, x[,5:6]);
#     rownames(rank.matrix) <-rownames(x);
#     colnames(rank.matrix) <-colnames(x);
#     rank.matrix <- data.frame(rank.matrix);
#     }
# 
# data.rank <- outlier.rank(gene.zrange.fraction.direction);
# 
# 
# ### Rank product to determine Top ranked genes #####
# # Function
# # x: ranked matrix
# # NA.number = Number of methods with non-NA should be more than assigned number
# outlier.rank.product <- function(x, NA.number = 0) {
#     rank <- as.numeric(x[1:4]);
#     num <- length(which(!is.na(rank)));
#     if (NA.number >= num) {
#         NA;
#         }
#     else {
#         prod(rank, na.rm = TRUE) / (num^num);
#         }
#     }
# 
# # NA.number = 3 : allt 4 methods have ranked value 
# rank.product.4 <- apply(data.rank, 1, outlier.rank.product, NA.number = 3);
# gene.rank.4 <- cbind(data.rank, rank.product.4);
# gene.rank.order.4 <- gene.rank.4[order(gene.rank.4$rank.product, decreasing = FALSE),];
gene.rank.order.4$Symbol[1:1000];






#################################################
max.fpkm.1000 <- apply(fpkm[,patient.part], 1, max);
BoutrosLab.plotting.general:::create.histogram(
    max.fpkm.log,
    breaks = 100,
    #xlimits = c(-0.1,5),
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    ylab.cex = 1,
    ylab.label = 'Count',
    xlab.label =  expression(paste('log'[10], '(FPKM+1)')),
    xlab.cex = 1,
    xaxis.cex = 1, 
    yaxis.cex = 1,
    main.cex = 1.3,
    type = 'count',
    main = expression(paste('The maximum value of log'[10], '(FPKM+1)'))
    );



# made white for all colours from 0-5, then add the colour-ramp above that?
# remove patient names and gene names
outlier.heatmap.rank <- function(x) {
    fpkm <- fpkm.tumor.symbol.filter[rownames(fpkm.tumor.symbol.filter) %in% rownames(x)[1:1000],];
    fpkm.log <- log10((fpkm[ , 1:(length(fpkm)-1)])+1);
    #fpkm.log[fpkm.log < log10(1+1)] <- 0;
    max.fpkm.log <- apply(fpkm.log, 1, max);
    max.col <- round(max(max.fpkm.log) - log10(5+1), digits = 2)
    mid.blue <- colorRampPalette(c('white', 'dodgerblue4'))(n = 100)[95];
    my_palette <- colorRampPalette(c('white', mid.blue, mid.blue,'dodgerblue4'))(n = max.col*100);  
    
    final.col <-  c(rep('white', round(log10(5+1), digits = 2)*100), my_palette)
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = fpkm.log,
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NULL,
        yaxis.cex = 0.3,
        xaxis.lab = NULL,
        xaxis.cex = 0.2,
        main = paste('FPKM value of top 1000 ranked genes in log10 space'),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = TRUE,
        colour.alpha = 0.2,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        ylab.label = 'Patients',
        ylab.cex = 1,
        xlab.label = 'Genes',
        xlab.cex = 1,
        colour.scheme = final.col,
        at = seq(0,max(max.fpkm.log),0.01),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

# NA.number = 3 : all 4 methods have ranked value 
outlier.heatmap.rank(gene.rank.order.4);

#################################################





### Heatmap of TOP ranked genes ###
# Top 1000 genes in FPKM space
outlier.heatmap.rank <- function(x) {
    fpkm <- fpkm.tumor.symbol.filter[rownames(fpkm.tumor.symbol.filter) %in% rownames(x)[1:1000],];
    fpkm.log <- log10((fpkm[ , 1:(length(fpkm)-1)])+1);
    max.fpkm.log <- apply(fpkm.log, 1, max);
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = fpkm.log,
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = fpkm$Symbol,
        xaxis.cex = 0.2,
        main = paste('FPKM value of top 1000 ranked genes in log10 space'),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = TRUE,
        colour.alpha = 0.4,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        ylab.label = 'Patients',
        ylab.cex = 1,
        xlab.label = 'Genes',
        xlab.cex = 1,
        colour.scheme = c('white', 'dodgerblue4'),
        at = seq(0,max(max.fpkm.log),0.001),
        colourkey.cex = 1,
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

# NA.number = 3 : all 4 methods have ranked value 
outlier.heatmap.rank(gene.rank.order.4);


# Top 1000 genes in z-score space
outlier.heatmap.rank.zscore.rank <- function(x, y) {
    zscore.rank <- x[rownames(x) %in% rownames(y)[1:1000], ];
    zscore.rank.order.na <- na.omit(zscore.rank);
    legend.col <- list(
            legend = list(
                colours = c('darkred', 'white', 'dodgerblue4'),
                title = expression(underline('z-score')), 
                labels = c('-5','5'),
                size = 3,
                label.cex = 1, 
                continuous = TRUE,
                height = 3
                ),
            legend = list(
                colours ='dodgerblue4',
                labels = '> 5',
                size = 3,
                label.cex = 0.7
                )
            );
    fpkm.heat <- BoutrosLab.plotting.general:::create.heatmap(
        x = zscore.rank.order.na[, 1:(length(x)-2)],
        clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
        yaxis.lab = NA,
        yaxis.cex = 0.3,
        xaxis.lab = zscore.rank.order.na$Symbol,
        xaxis.cex = 0.2,
        main = paste('The z-score of top 1000 ranked genes calculated using',
                     sub('.{7}$', '', substitute(x))),
        main.cex = 1.3,
        grid.col = FALSE,
        print.colour.key = FALSE,
        ylab.label = 'Patients',
        ylab.cex = 1,
        xlab.label = 'Genes',
        xlab.cex = 1,
        yaxis.tck = 0.1,
        xaxis.tck = 0.1,
        colour.scheme = c('darkred', 'white', 'dodgerblue4'),
        colour.centering.value = 0,
        at = seq(-5,5,0.01),
        colourkey.cex = 1,
        covariate.legend = legend.col,
        legend.title.just = 'left',
        resolution = 300,
        rows.distance.method = 'euclidean',
        cols.distance.method = 'euclidean'
        );
    fpkm.heat;
    }

# NA.number = 3 : all 4 methods have ranked value 
outlier.heatmap.rank.zscore.rank(median.zscore, gene.rank.order.4);




#################################################
x <- median.zscore
y <- gene.rank.order.4
zscore.rank <- x[rownames(x) %in% rownames(y)[1:1000], ];
    zscore.rank.order.na <- na.omit(zscore.rank);
zscore.rank.order.na.patient <- zscore.rank.order.na[,patient.part]
zscore.rank.order.na.patient[zscore.rank.order.na.patient < 1 & zscore.rank.order.na.patient> -1] <- 1

log.negative <- function (x) { 
  log <- NULL;
  for (i in seq_along(patient.part)){
    if (x[i] < 0) {
      log[i] <- -log10(-x[i])
    } else {
      log[i] <- log10(x[i])
    }
  }
  log
}
aa <- apply(zscore.rank.order.na.patient, 1, log.negative)
aaa <- data.frame(t(aa))

mid.red <- colorRampPalette(c('white', 'darkred'))(n = 100)[95];
mid.blue <- colorRampPalette(c('white', 'dodgerblue4'))(n = 100)[95];
in.red <- colorRampPalette(c('white', 'darkred'))(n = 100)[85];
in.blue <- colorRampPalette(c('white', 'dodgerblue4'))(n = 100)[85];
my_palette <- colorRampPalette(c('darkred','darkred',  mid.red,in.red, 'white',in.blue, mid.blue, 'dodgerblue4', 'dodgerblue4'))(n = 2000);
BoutrosLab.plotting.general:::create.heatmap(
            x = aaa,
            clustering.method = 'ward.D2',
        cluster.dimensions = 'both',
            yaxis.lab = NULL,
            # yaxis.cex = 0.3,
            xaxis.lab = NULL,
            # xaxis.cex = 0.2,
            main = paste('The robust z-score of top 1000 ranked outliers by median in log10 scale'),
            main.cex = 1.3,
            grid.col = FALSE,
            print.colour.key = TRUE,
            ylab.label = 'Patients',
            ylab.cex = 1,
            xlab.label = 'Genes',
            xlab.cex = 1,
            yaxis.tck = 0.1,
            xaxis.tck = 0.1,
            colour.scheme = my_palette,
            colour.centering.value = 0,
            colour.alpha = 0.2,
            at = seq(-max(aaa),max(aaa),0.01),
            colourkey.labels.at = seq(-round(max(aaa), digits = 0),round(max(aaa), digits = 0),1),
            colourkey.cex = 0.8,
            # covariate.legend = legend.col,
            # legend.title.just = 'left',
            # resolution = 300,
            rows.distance.method = 'euclidean',
            cols.distance.method = 'euclidean'
            );  

#################################################





 
# ### Count the number of outliers (top1000) per patients ###
# # x: ranked gene data (gene.rank.order.4)
# # y: patient-wise outlier matrix
# patient.outlier <- function(x, y) {
#     x.1000 <- x[1:1000,];
#     y.gene <- y[4:nrow(y),];
#     y.1000 <- y.gene[rownames(y.gene) %in% rownames(x.1000),];
#     apply(y.1000, 2, sum);
#     }
# 
# patient.median.adjust.p.sum <- patient.outlier(gene.rank.order.4, adjust.p.median.sum);
# hist(patient.median.adjust.p.sum,
#      main = 'number of outliers per patient: adjust.p-value < 0.05',
#      xlab = 'number of outliers');
# 
# ### Heatmap of outliers ordered by the number of outliers per patient ###
# # x: matrix with the number of outliers per patients
# # y: z-score data
# # z: ranked gene data (gene.rank.order.4)
# 
# patient.order.outlier.heatmap <- function (x, y, z) {
#     patient.order <- names(sort(x));
#     zscore.rank <- y[rownames(y) %in% rownames(z)[1:1000],];
#     zscore.rank.order <- zscore.rank[, c(match(patient.order, colnames(zscore.rank)), length(y))];
#     zscore.rank.order.na <- na.omit(zscore.rank.order);
#     zscore.heat <- BoutrosLab.plotting.general:::create.heatmap(
#         x = zscore.rank.order.na[,patient.part],
#         clustering.method = 'none',
#         cluster.dimensions = 'none',
#         yaxis.lab = NA,
#         yaxis.cex = 0.3,
#         xaxis.lab = zscore.rank.order.na$Symbol,
#         xaxis.cex = 0.3,
#         main = paste('The z-score of top 1000 genes calculated using',
#                      sub('.{7}$', '', substitute(y)),
#                      ' - ordered patient'),
#         main.cex = 1.5,
#         grid.col = FALSE,
#         print.colour.key = TRUE,
#         yaxis.tck = 0.1,
#         xaxis.tck = 0.1,
#         colour.scheme = c('red4', 'white', 'dodgerblue4'),
#         colour.centering.value = 0,
#         at = seq(-5,5,0.001),
#         colourkey.cex = 1,
#         resolution = 300,
#         rows.distance.method = 'none',
#         cols.distance.method = 'none'
#         );
#     zscore.heat; 
#     }
# 
# patient.order.outlier.heatmap(patient.median.adjust.p.sum, median.zscore, gene.rank.order.4);


```

## 11.1 Waterfall plot of FPKM values of top ranked genes
```{r, fig.width=9, fig.height=6, warning = FALSE}

outlier.fpkm.waterfallplot <- function(x, y, plot.num = 1) {
    for (i in 1:plot.num ) {
        fpkm.gene <- as.numeric(y[rownames(x)[i],patient.part]);
        sample <- t(y[i,patient.part]);
        sample.row <-  data.frame(row.names(sample))
        fpkm.b <- cbind(sample.row, fpkm.gene);
        colnames(fpkm.b) <- c('patient', 'gene');
        nonzero.fpkm <- round(sum(ifelse(fpkm.b$gene == 0, 0, 1))/length(patient.part)*100, 2);
        fpkm.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = fpkm.b,
            main = paste('FPKM value of the top ranked outlier -', x$Symbol[i]),
            main.cex = 1.5,
            ylab.lab = 'FPKM',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.1,
            yaxis.tck = 0.1,
            xlab.lab = 'Patient',
            key = list(
                title = expression(underline('Fraction of patient')),
                text = list(
                    lab = paste(as.character(nonzero.fpkm),'%'),
                    cex = 1.1,
                    col = 'black'
                    ),
                x = 0.75,
                y = 0.9,
                padding.text = 3,
                columns = 1
                ),
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.fontface = 'bold',
            col = 'black',
            sample.order = 'decreasing'
            );
        print(fpkm.bar);
        }
    }


outlier.fpkm.waterfallplot(gene.rank.order.4, fpkm.tumor.symbol.filter, plot.num = 100);


```


## 11. Multi-Waterfall plot with clinical data
```{r, fig.width=14, fig.height=15.05, warning = FALSE}
### Make covariates ###

# Match the patients between fpkm.data vs clinical.data
clinical.data$Sample.ID <- gsub('-', '.', clinical.data$Sample.ID);
patinet.id <- substr(colnames(fpkm.tumor.symbol.filter[,patient.part]), 1, 15);
clinical.data.match <- clinical.data[clinical.data$Sample.ID %in% patinet.id,];
duplicate.sample <- clinical.data.match[duplicated(clinical.data.match$Sample.ID),]$Sample.ID;
clinical.data.match.dup <- clinical.data.match[!(clinical.data.match$Sample.ID %in% duplicate.sample),];
clinical.outcome <- clinical.data.match.dup[match(patinet.id, clinical.data.match.dup$Sample.ID),];


## 1. ISUP GG ##
primary.gs <- clinical.outcome$Gleason.pattern.primary;
secondary.gs <- clinical.outcome$Gleason.pattern.secondary;
final.gs <- primary.gs + secondary.gs;
isup <- data.frame();
for (i in 1:length(primary.gs)) {
    if (final.gs[i] <= 6) {
        isup[i,1] <- 1;
        }
    else if (3 == primary.gs[i] & 4 == secondary.gs[i]) {
        isup[i,1] <- 2;
        }
    else if (4 == primary.gs[i] & 3 == secondary.gs[i]) {
        isup[i,1] <- 3;
        }
    else if (8 == final.gs[i]) {
        isup[i,1] <- 4;
        }
    else if (final.gs[i] >= 9) {
        isup[i,1] <- 5;
        }
    }

## 2. PSA ##
# 0~1 / 1~10 / 10~100 / 100<
psa <- clinical.outcome$Psa.most.recent.results;
psa.stage <- data.frame();
for (i in 1:length(psa)) {
    if (is.na(psa[i])) {
       psa.stage[i,1] <- 6;
      }
    else if (psa[i] <= 1) {
        psa.stage[i,1] <- 7;
        }
    else if (psa[i] > 1 & psa[i] <= 10) {
        psa.stage[i,1] <- 8;
        }
    else if (psa[i] > 10 & psa[i] <= 100) {
        psa.stage[i,1] <- 9;
        }
    else if (psa[i] > 100) {
        psa.stage[i,1] <- 10;
        }
    }

## 3. Age ##
# 40~49 / 50~59 / 60~69 / 70<
age <- clinical.outcome$Diagnosis.Age;
age.stage <- data.frame();
for (i in 1:length(age)) {
    if (is.na(age[i])) {
       age.stage[i,1] <- 6;
      }
    else if (age[i] < 50) {
        age.stage[i,1] <- 11;
        }
    else if (age[i] >= 50 & age[i] < 60) {
        age.stage[i,1] <- 12;
        }
    else if (age[i] >= 60 & age[i] < 70) {
        age.stage[i,1] <- 13;
        }
    else if (age[i] >= 70) {
        age.stage[i,1] <- 14;
        }
    }

## 4. Tumor Stage ##
# T2 / T3 / T4
grade <- clinical.outcome$American.Joint.Committee.on.Cancer.Tumor.Stage.Code;
grade.sub <- substr(grade, 1, 2);
grade.sub.stage <- data.frame();
for (i in 1:length(grade.sub)) {
    if (is.na(grade.sub[i])) {
       grade.sub.stage[i,1] <- 6;
        }
    else if ('T2' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 15;
        }
    else if ('T3' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 16;
        }
    else if ('T4' == grade.sub[i]) {
        grade.sub.stage[i,1] <- 17;
        }
    }

### Make data.frame for heatmap ###
all.clinical <- cbind(isup, psa.stage, age.stage, grade.sub.stage);
rownames(all.clinical) <- colnames(fpkm.tumor.symbol.filter[,patient.part]);


## Waterfall plot
# x: fpkm.tumor.symbol.filter file
# a: gene.rank.order.4 - ranked gene file
# b: mean.zscore
# c: trimmean.zscore
# d: median.zscore
# e: kmean.fraction
# f: all.clinical - clinical data
# num: number of plots

outlier.multiwaterfallplot <- function(x, a, b, c, d, e, f, num = 1) {
   fpkm <- x[match(rownames(a), rownames(x)),];
   patient.part <- 1: (length(fpkm)-1);

    for (k in 1: num) {
        # FPKM plot
        fpkm.gene <- as.numeric(fpkm[k, patient.part]);
        fpkm.gene.t <- t(fpkm[k, patient.part]);
        row.fpkm.gene.t <- data.frame(row.names(fpkm.gene.t));
        fpkm.value <- cbind(row.fpkm.gene.t, fpkm.gene);
        colnames(fpkm.value) <- c('patient', 'gene');
        fpkm.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = fpkm.value,
            main = a$Symbol[k],
            main.cex = 1.5,
            ylab.lab = 'FPKM',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );

        # Mean plot
        b.order <- b[match(rownames(a), rownames(b)),];
        mean.gene <- as.numeric(b.order[k, patient.part]);
        mean.gene.t <- t(b.order[k, patient.part]);
        row.mean.gene.t <- data.frame(row.names(mean.gene.t));
        mean.value <- cbind(row.mean.gene.t, fpkm.gene, mean.gene);
        colnames(mean.value) <- c('patient', 'fpkm', 'gene');
        mean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = mean.value,
            main = paste(b.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(b))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (mean)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );

        # Trimmean plot
        c.order <- c[match(rownames(a), rownames(c)),];
        trimmean.gene <- as.numeric(c.order[k, patient.part]);
        trimmean.gene.t <- t(c.order[k, patient.part]);
        row.trimmean.gene.t <- data.frame(row.names(trimmean.gene.t));
        trimmean.value <- cbind(row.trimmean.gene.t, fpkm.gene, trimmean.gene);
        colnames(trimmean.value) <- c('patient', 'fpkm', 'gene');
        trimmean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = trimmean.value,
            main = paste(c.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(c))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score (trimmed mean)',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );

        # Median plot
        d.order <- d[match(rownames(a), rownames(d)),];
        median.gene <- as.numeric(d.order[k, patient.part]);
        median.gene.t <- t(d.order[k, patient.part]);
        row.median.gene.t <- data.frame(row.names(median.gene.t));
        median.value <- cbind(row.median.gene.t, fpkm.gene, median.gene);
        colnames(median.value) <- c('patient', 'fpkm', 'gene');
        median.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ patient,
            data = median.value,
            main = paste(d.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(d))),
            main.cex = 1.5,
            ylab.lab = 'Z-Score',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yaxis.fontface = 'bold',
            sample.order = 'decreasing'
            );


        # Kmean plot
        e.order <- e[match(rownames(a), rownames(e)),];
        kmean.gene <- as.numeric(e.order[k, patient.part]);
        kmean.gene.t <- t(e.order[k, patient.part]);
        row.kmean.gene.t <- data.frame(row.names(kmean.gene.t));
        kmean.value <- cbind(row.kmean.gene.t, fpkm.gene, kmean.gene);
        colnames(kmean.value) <- c('patient', 'fpkm', 'gene');
        kmean.value.order <- kmean.value[order(kmean.value$fpkm, decreasing = TRUE),];
        kmean.value.order.number <- data.frame(cbind(c(1:length(patient.part)),
                                                     kmean.value.order));
        colnames(kmean.value.order.number) <- c('number', 'patient', 'fpkm', 'gene');
        kmean.bar <- BoutrosLab.plotting.general:::create.barplot(
            formula = gene ~ number,
            data = kmean.value.order.number,
            main = paste(e.order$Symbol[k],
                         'calculated using',
                         sub('.{7}.', '', substitute(e))),
            main.cex = 1.5,
            ylab.lab = 'z-score',
            yaxis.cex = 1,
            ylab.cex = 1,
            xaxis.tck = 0.2,
            xaxis.lab = kmean.value.order.number$patient,
            xlab.lab = 'Patient',
            xaxis.rot = 90,
            xaxis.cex = 0.3,
            xlab.cex = 1,
            yaxis.tck = 1,
            border.lwd  = 0.2,
            yat = seq(0,2,1),
            yaxis.fontface = 'bold'
            );

        ### Clinical data ###
        # Order the patients
        all.clinical.order <- f[match(kmean.value.order.number$patient, rownames(f)),];
        # Color
        isup.col <- BoutrosLab.plotting.general:::colour.gradient('lightyellow3', 5);
        psa.col.4 <- BoutrosLab.plotting.general:::colour.gradient('orange', 4);
        psa.col <- c('white', psa.col.4);
        age.col.4 <- BoutrosLab.plotting.general:::colour.gradient('lightpink', 4);
        grade.col.3 <- BoutrosLab.plotting.general:::colour.gradient('skyblue4', 3);
        all.col <- c(isup.col, psa.col, age.col.4, grade.col.3);
        #Make heatmap
        all.cov.heatmap <- BoutrosLab.plotting.general:::create.heatmap(
            x = all.clinical.order,
            clustering.method = 'none',
            colour.scheme = all.col,
            total.colours = 18,
            row.colour = 'black',
            col.colour = 'black',
            grid.row = TRUE,
            grid.col = TRUE,
            yaxis.tck = 0,
            xaxis.tck = 0,
            print.colour.key = FALSE,
            force.grid.row = TRUE,
            force.grid.col = TRUE
            );
        #Make legend
        legend.clinic <- BoutrosLab.plotting.general:::legend.grob(
            list(
                # create legend for ISUP
                legend = list(
                    colours = isup.col,
                    title = expression(underline('ISUP')),
                    labels = c('1', '2', '3', '4', '5'),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5,
                    border = 'black'
                    ),
                # create legend for PSA
                legend = list(
                    colours = psa.col,
                    title = expression(underline('PSA level')),
                    labels = c('NA', expression('\u2264 '*'1'), '1 - 10', '10 - 100', expression('\u2265 '*'100')),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5,
                    border = 'black'
                    ),
                # create legend for Age
                legend = list(
                    colours = age.col.4,
                    title = expression(underline('Age')),
                    labels = c(expression('\u2264 '*'49'), '50 - 59', '60 - 69', expression('\u2265 '*'70')),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5,
                    border = 'black'
                    ),
                # create legend for Grade
                legend = list(
                    colours = c('white', grade.col.3),
                    title = expression(underline('Tumor Grade')),
                    labels = c('NA', 'T2', 'T3', 'T4'),
                    size = 2,
                    title.cex = 0.5,
                    label.cex = 0.5,
                    border = 'black'
                    )
                ),
            title.just = 'left',
            title.fontface = 'plain')


        ###Final multiplot
        nonzero.fpkm <- round(sum(ifelse(fpkm.value$gene == 0, 0, 1))/length(patient.part)*100, 2);
        final.plot <- BoutrosLab.plotting.general:::create.multiplot(
            plot.objects = list(kmean.bar, median.bar, trimmean.bar, mean.bar, fpkm.bar, all.cov.heatmap),
            main = paste(a$Symbol[k]),
            xlab.label = 'Patient',
            ylab.label = c('', '', 'FPKM', '', '', 'z-score (mean)',  '', '',
                           'z-score (trimmmed mean)', '', '', 'z-score (median)',
                           '', '',  'kmean', ''),
            y.relation = 'free',
            panel.heights = c(1, 2, 2, 2, 2, 2),
            legend = list(right = list(fun = legend.clinic)),
            print.new.legend = TRUE,
            y.spacing = 0.5,
            key = list(
                title = expression(underline('Fraction of patient')),
                text = list(
                    lab = paste(as.character(nonzero.fpkm),'%'),
                    cex = 1,
                    col = 'black'
                    ),
                x = 0.9,
                y = 0.88,
                padding.text = 2,
                cex = 0.7,
                columns = 1
                ),
            main.cex = 1.3,
            xaxis.cex = 0.2,
            yaxis.cex = 0.7,
            yaxis.tck = 0.1,
            ylab.cex = 0.7,
            xlab.cex = 1,
            xaxis.lab = fpkm.value$patient,
            xaxis.rot = 90,
            xaxis.tck = 0.1
        )
        print(final.plot);
        }
    }

# Multi-waterfall plot
outlier.multiwaterfallplot(fpkm.tumor.symbol.filter, gene.rank.order.4, mean.zscore,
                           trimmean.zscore, median.zscore, kmean.fraction, all.clinical, num = 5);


```



## 12. Function for making bar plot of rank product on each chromosome position
```{r, fig.width=12, fig.height=11}
# # Chromosomal position of rank product using bar plot
# rank.chromosomal.position.bar <- function(x, chr.num = 24, data.col = 'steelblue4') {
#     gene.list <- rownames(x);
#     gene.list.sub <- substr(gene.list, 1, 15);
#     ensembl <- biomaRt:::useEnsembl(biomart = 'ensembl', 
#                                     dataset = 'hsapiens_gene_ensembl', 
#                                     mirror = 'uswest');
#     ensembl <- biomaRt:::useDataset(dataset = 'hsapiens_gene_ensembl', mart = ensembl);
#     gene.position <- biomaRt:::getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'chromosome_name',
#                                                     'start_position', 'end_position', 'band'),
#                                      filters = 'ensembl_gene_id', 
#                                      values = gene.list.sub, 
#                                      mart = ensembl);
# 
#     #Get the gene, position matrix
#     gene.biomart <- subset(x, gene.list.sub %in% gene.position$ensembl_gene_id);
#     gene.position.order <- gene.position[order(as.numeric(gene.position$chromosome_name), 
#                                                as.numeric(gene.position$start_position), 
#                                                decreasing = FALSE),];
#     gene.biomart.fpkm <- gene.biomart[match(gene.position.order$ensembl_gene_id, 
#                                             substr(rownames(gene.biomart), 1, 15)),];
#     chr.ord <- cbind(gene.biomart.fpkm, 
#                      gene.position.order[, colnames(gene.position.order) %in% c('chromosome_name', 'start_position', 'end_position')]);
#     chr.ord.na <- na.omit(chr.ord);
#     chr.name <- c('1', '2', '3', '4', '5', '6', '7', '8', '9', '10',
#                   '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', 
#                   '21', '22', 'MT', 'X', 'Y');
#     chr.ord.na.numeric <- chr.ord.na;
#     for (i in 1 : nrow(chr.ord.na.numeric)){
#         if('MT' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '23';
#             }
#         if('X' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '24';
#             }
#         if('Y' == chr.ord.na.numeric$chromosome_name[i]) {
#             chr.ord.na.numeric$chromosome_name[i] <- '25';
#             }
#         }
# 
#     for (i in 1 : chr.num) {
#     chr <- na.omit(chr.ord.na.numeric[chr.ord.na.numeric$chromosome_name == i,]);
#     chr.number <- cbind(chr, c(1:nrow(chr)));
#     chr.heat <- BoutrosLab.plotting.general:::create.barplot(
#             formula = -log10(rank.product.6) ~ c(1:nrow(chr)),
#             data = chr.number,
#             main = paste('Chr', chr.name[i], 
#                          '- Rank Product of',
#                          substr(substitute(x), 1, 4)),
#             main.cex = 1.3,
#             ylab.lab = '-log10(Rank product)',
#             yaxis.cex = 1,
#             ylab.cex = 1,
#             xaxis.tck = 0,
#             xaxis.lab = rep('', nrow(chr)),
#             xlab.lab = 'gene',
#             xaxis.rot = 90,
#             xaxis.cex = 0.3,
#             xlab.cex = 1,
#             yaxis.tck = 1,
#             border.lwd  = 0.1,
#             # yaxis.fontface = 'bold'
#             col = data.col
#             );
#         print(chr.heat);
#         }
#     }
# 
# rank.chromosomal.position.bar(gene.rank.order.4, chr.num = 1);


```


# The correlation of z-score range and median abundance
```{r}
### Correlation of gene rank between two datasets - median
median.fpkm <- apply(fpkm.tumor.symbol.filter[,patient.part], 1, median);
median.zrange.fpkm <- data.frame(cbind(median.zscore$zrange, median.fpkm));
rownames(median.zrange.fpkm) <- rownames(median.zscore);
colnames(median.zrange.fpkm) <- c('zrange', 'fpkm'); 
cor(median.zrange.fpkm[,1:2], method = 'spearman')
median.zrange.fpkm.log <- median.zrange.fpkm
median.zrange.fpkm.log$fpkm <- log10(median.zrange.fpkm$fpkm)
median.zrange.fpkm.log$zrange <- log10(median.zrange.fpkm$zrange)
# Scatter plot for each gene
BoutrosLab.plotting.general:::create.scatterplot(
    formula = zrange ~ fpkm,
    data = median.zrange.fpkm.log,
    main = 'The correlation of the robust z-score range and median FPKM', 
    main.cex = 1.3,
    ylab.label = expression('log'[10]*'(Z'[i]^'R'*' range)'),
    xlab.label = expression('log'[10]*'(Median FPKM)'),
    xlab.cex = 1,
    ylab.cex = 1,
    xaxis.cex = 0.7,
    yaxis.cex = 0.7,
    xaxis.fontface = 1,
    yaxis.fontface = 1,
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    #xlimits = c(0, 35),
    #ylimits = c(0, 35),
    #xat = seq(0, 16, 4),
    #yat = seq(0, 16, 4),
    type = c('p', 'r', 'g'),
    cex = 0.3,
    lwd = 1.5,
    text.guess.labels = TRUE, 
    text.guess.skip.labels = FALSE,
    legend = list(
        inside = list(
        fun = draw.key,
        args = list(
            key = get.corr.key(
                y = median.zrange.fpkm$zrange,
                x = median.zrange.fpkm$fpkm,
                label.items = c('spearman'), alpha.background = 0,
                key.cex = 1
                ) 
            ),
        x = 0.03,
        y = 0.95, corner = c(0,1) )
    ),
    resolution = 300);
# Scatter plot for each gene
BoutrosLab.plotting.general:::create.scatterplot(
    formula = zrange ~ fpkm,
    data = median.zrange.fpkm,
    main = 'The correlation of the robust z-score range and median FPKM', 
    main.cex = 1.3,
    ylab.label = expression('log'[10]*'(Z'[i]^'R'*' range)'),
    xlab.label = expression('log'[10]*'(Median FPKM)'),
    xlab.cex = 1,
    ylab.cex = 1,
    xaxis.cex = 0.7,
    yaxis.cex = 0.7,
    xaxis.fontface = 1,
    yaxis.fontface = 1,
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    xlimits = c(-500, max(median.zrange.fpkm$fpkm)+100),
    ylimits = c(-500, max(median.zrange.fpkm$zrange)+100),
    #xat = seq(0, 16, 4),
    #yat = seq(0, 16, 4),
    type = c('g','p'),
    cex = 0.3,
    lwd = 1.5,
    text.guess.labels = TRUE, 
    text.guess.skip.labels = FALSE,
    legend = list(
        inside = list(
        fun = draw.key,
        args = list(
            key = get.corr.key(
                y = median.zrange.fpkm$zrange,
                x = median.zrange.fpkm$fpkm,
                label.items = c('spearman'), alpha.background = 0,
                key.cex = 1
                ) 
            ),
        x = 0.03,
        y = 0.95, corner = c(0,1) )
    ),
    resolution = 300);
# Scatter plot for each gene
BoutrosLab.plotting.general:::create.scatterplot(
    formula = zrange ~ fpkm,
    data = median.zrange.fpkm,
    main = 'The correlation of the robust z-score range and median FPKM', 
    main.cex = 1.3,
    ylab.label = expression('log'[10]*'(Z'[i]^'R'*' range)'),
    xlab.label = expression('log'[10]*'(Median FPKM)'),
    xlab.cex = 1,
    ylab.cex = 1,
    xaxis.cex = 0.7,
    yaxis.cex = 0.7,
    xaxis.fontface = 1,
    yaxis.fontface = 1,
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    xlimits = c(-500, 2000),
    ylimits = c(-500, 5000),
    #xat = seq(0, 16, 4),
    #yat = seq(0, 16, 4),
    type = c('g','p'),
    cex = 0.3,
    lwd = 1.5,
    text.guess.labels = TRUE, 
    text.guess.skip.labels = FALSE,
    legend = list(
        inside = list(
        fun = draw.key,
        args = list(
            key = get.corr.key(
                y = median.zrange.fpkm$zrange,
                x = median.zrange.fpkm$fpkm,
                label.items = c('spearman'), alpha.background = 0,
                key.cex = 1
                ) 
            ),
        x = 0.03,
        y = 0.95, corner = c(0,1) )
    ),
    resolution = 300);


### Correlation of gene rank between two datasets - mean
mean.fpkm <- apply(fpkm.tumor.symbol.filter[,patient.part], 1, mean);
mean.zrange.fpkm <- data.frame(cbind(mean.zscore$zrange, mean.fpkm));
rownames(mean.zrange.fpkm) <- rownames(mean.zscore);
colnames(mean.zrange.fpkm) <- c('zrange', 'fpkm'); 
cor(mean.zrange.fpkm[,1:2], method = 'spearman')
mean.zrange.fpkm.log <- mean.zrange.fpkm
mean.zrange.fpkm.log$fpkm <- log10(mean.zrange.fpkm$fpkm)
mean.zrange.fpkm.log$zrange <- log10(mean.zrange.fpkm$zrange)
# Scatter plot for each gene
BoutrosLab.plotting.general:::create.scatterplot(
    formula = zrange ~ fpkm,
    data = mean.zrange.fpkm.log,
    main = 'The correlation of the z-score range and median FPKM', 
    main.cex = 1.3,
    ylab.label = expression('log'[10]*'(Z'[i]*' range)'),
    xlab.label = expression('log'[10]*'(Median FPKM)'),
    xlab.cex = 1,
    ylab.cex = 1,
    xaxis.cex = 0.7,
    yaxis.cex = 0.7,
    xaxis.fontface = 1,
    yaxis.fontface = 1,
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    #xlimits = c(0, 35),
    ylimits = c(0.5, 1.5),
    #xat = seq(0, 16, 4),
    #yat = seq(0, 16, 4),
    type = c('p', 'r', 'g'),
    cex = 0.3,
    lwd = 1.5,
    text.guess.labels = TRUE, 
    text.guess.skip.labels = FALSE,
    legend = list(
        inside = list(
        fun = draw.key,
        args = list(
            key = get.corr.key(
                y = mean.zrange.fpkm$zrange,
                x = mean.zrange.fpkm$fpkm,
                label.items = c('spearman'), alpha.background = 0,
                key.cex = 1
                ) 
            ),
        x = 0.03,
        y = 0.95, corner = c(0,1) )
    ),
    resolution = 300);



### Correlation of gene rank between two datasets - Trimmed mean
trimmean.function <- function(x) {mean(x, trim = 0.05)};
trimmean.fpkm <- apply(fpkm.tumor.symbol.filter[,patient.part], 1, trimmean.function);
trimmean.zrange.fpkm <- data.frame(cbind(trimmean.zscore$zrange, trimmean.fpkm));
rownames(trimmean.zrange.fpkm) <- rownames(trimmean.zscore);
colnames(trimmean.zrange.fpkm) <- c('zrange', 'fpkm'); 
cor(trimmean.zrange.fpkm[,1:2], method = 'spearman')
trimmean.zrange.fpkm.log <- trimmean.zrange.fpkm
trimmean.zrange.fpkm.log$fpkm <- log10(trimmean.zrange.fpkm$fpkm)
trimmean.zrange.fpkm.log$zrange <- log10(trimmean.zrange.fpkm$zrange)
# Scatter plot for each gene
BoutrosLab.plotting.general:::create.scatterplot(
    formula = zrange ~ fpkm,
    data = trimmean.zrange.fpkm.log,
    main = 'The correlation of the modified z-score range and median FPKM', 
    main.cex = 1.3,
    ylab.label = expression('log'[10]*'(Z'[i]^'T'*' range)'),
    xlab.label = expression('log'[10]*'(Median FPKM)'),
    xlab.cex = 1,
    ylab.cex = 1,
    xaxis.cex = 0.7,
    yaxis.cex = 0.7,
    xaxis.fontface = 1,
    yaxis.fontface = 1,
    yaxis.tck = 0.2,
    xaxis.tck = 0.2,
    #xlimits = c(0, 35),
    #ylimits = c(0, 35),
    #xat = seq(0, 16, 4),
    #yat = seq(0, 16, 4),
    type = c('p', 'r', 'g'),
    cex = 0.3,
    lwd = 1.5,
    text.guess.labels = TRUE, 
    text.guess.skip.labels = FALSE,
    legend = list(
        inside = list(
        fun = draw.key,
        args = list(
            key = get.corr.key(
                y = trimmean.zrange.fpkm.log$zrange,
                x = trimmean.zrange.fpkm.log$fpkm,
                label.items = c('spearman'), alpha.background = 0,
                key.cex = 1
                ) 
            ),
        x = 0.03,
        y = 0.95, corner = c(0,1) )
    ),
    resolution = 300);




# trimmean.function <- function(x) {mean(x, trim = 0.01)};
# trimmean.fpkm <- apply(fpkm.tumor.symbol.filter[,patient.part], 1, trimmean.function);
# mean.trimmean.dif <- mean.fpkm - trimmean.fpkm;
# mean.trimmean.dif.order <- sort(mean.trimmean.dif, decreasing = TRUE);
# mean.trimmean.symbol <- data.frame(cbind(mean.trimmean.dif.order, fpkm.tumor.symbol.filter[match(names(mean.trimmean.dif.order), rownames(fpkm.tumor.symbol.filter)),]$Symbol))
# sort(as.numeric(fpkm.tumor.symbol.filter[rownames(fpkm.tumor.symbol.filter) == 'ENSG00000122585.6',patient.part]), decreasing = FALSE)
```



## 13. File check - Check the correlation between FPKM and z-score
```{r}

# # Check the correlation between FPKM and z-score
# #  - if the correlation is low, error will occur.
# #  x: FPKM data
# #  y: z-score data
# data.match.check <- function(x, y) {
#     random.number <- sample(60308, 1000, replace = FALSE);
#     cor.1000 <- NA;
#     for ( i in 1:1000) {
#         cor.1000[i] <- cor(t(x[random.number[i],]),
#                            t(y[random.number[i],]),
#                           method = 'spearman');
#         }
#     if (mean(na.omit(cor.1000)) > 0.9) {
#         message('High correlation!');
#         }
#     else {
#         stop('Low correlation!');
#         }
#     }
# 
# 
# data.list <- list(mean.zscore,
#                   median.zscore,
#                   trimmean.zscore);
# 
# for (i in 1:length(data.list)) {
#     data.match.check(fpkm.tumor.symbol.filter[,patient.part], data.list[[i]][,patient.part]);
#     }
#         
        
```


## 14. Save session
```{r}
# library(BoutrosLab.utilities);
# ### Save session #####
# save(fpkm.tumor.symbol,
#      fpkm.tumor.symbol.filter,
#      patient.part,
#      molecular.data,
#      molecular.data.filter,
#      mean.zscore,
#      mean.nonzero.zscore,
#      median.zscore,
#      median.nonzero.zscore,
#      trimmean.zscore,
#      trimmean.nonzero.zscore,
#      kmean.fraction,
#      kmean.nonzero.fraction,
#      gene.zrange.fraction,
#      gene.zrange.fraction.direction,
#      gene.rank.order.4,
#      file = generate.filename('TCGA', 'PRAD', 'rda', file.date = Sys.Date())
#      );

```

